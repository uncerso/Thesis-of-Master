% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Программная инженерия\\Системное программирование},
    title              = {Исправление ошибок в зашумленных последовательностях при помощи графов сборки},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = 444,
    author             = {Клещин Антон Сергеевич},
    supervisorPosition = {доц. каф. СП, к. т. н.},
    supervisor         = {Литвинов Ю.\,В.},
    supervisorPositionx   = {доц. каф. стат. мод., к. ф.-м. н.},
    supervisorx           = {Коробейников А.\,И.},
    supervisorPositiony   = {старший н. с., к. ф.-м. н.},
    supervisory           = {Пржибельский А.\,Д.},
    reviewerPosition  = {приглашённый н. с., к. ф.-м. н.},
    reviewer          = {Нурк С.\,Ю.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Software and Administration of Information Systems \\ Software Engineering},
    title              = {Error correction in noisy sequences using assembly graphs},
    type               = {master},
    author             = {Anton Kleshchin},
    supervisorPosition = {C.Sc., Associate Professor},
    supervisor         = {Yurii Litvinov},
    supervisorPositionx   = {Ph.D., Associate Professor},
    supervisorx           = {Anton Korobeynikov},
    supervisorPositiony   = {Ph.D., Senior Research Fellow},
    supervisory           = {Andrey Prjibelski},
    reviewerPosition  = {Ph.D., Visiting Fellow},
    reviewer          = {Sergey Nurk},
}
\maketitle
\tableofcontents
\setcounter{secnumdepth}{4}
%==============================================================================
% У введения нет номера главы
\section*{Введение}
Сборка геномов является одной из важнейших задач биоинформатики. За многие годы учёным уже удалось собрать, а затем и расшифровать большое количество геномов. Несмотря на это, автоматическая реконструкция генома всё ещё остаётся сложной вычислительной задачей \cite{sohn2018present, art:collins2018challenge}.

Обычно сборка генома происходит из ридов (англ. reads) --- фрагментов ДНК, которые получаются в результате секвенирования, а результатом являются контиги (англ. contigs, восстановленные части ДНК из ридов) или скаффолды (англ. scaffolds, восстановленные части ДНК с пропусками известной длины).

Технологии секвенирования не стоят на месте: появилось третье поколение, позволяющие получать длинные риды дешевле, но количество ошибок в них на порядок выше \cite{art:reads}. Несмотря на то, что есть способы частично бороться с этими ошибками \cite{art:alic2016objective}, для улучшения результатов сборки можно прибегнуть к другим методам. Например, для небольших геномов активно применяется метод гибридной сборки \cite{art:hybridSpades}, в которой одновременно используются как длинные риды с большим количеством ошибок, так и короткие, уровень ошибок в которых минимален. Короткие риды здесь выступают основным материалом для построения графа сборки, а длинные риды позволяют находить более длинные пути в этом графе, которые в дальнейшем становятся контигами. К сожалению, для больших геномов получить достаточное количество коротких ридов оказывается очень дорого.

Кроме того, даже с небольшими геномами есть проблемы. Например, есть штаммы бактерий, получить большое количество экземпляров которых крайне сложно. В этом случае покрытие генома полученными ридами оказывается очень низким, как и качество длинных ридов. Более того, некоторые штаммы вообще невозможно получить без окружающих их бактерий, поэтому прибегают к метагеномике --- направлению геномики, в котором рассматриваются ДНК не отдельного организма, а сразу множества. Покрытие ридами генома каждой бактерии в рамках одной сборки может сильно отличаться, что только ухудшает качество контигов бактерий с низким покрытием.

Уже существуют инструменты, которые стараются исправлять контиги, используя риды. Их основная идея --- найти выравнивания ридов на контиги и с помощью какого-нибудь алгоритма консенсуса решить, какие нуклеотиды исправлять. При этом подходе теряется информация, которую нам даёт граф сборки. Во-первых, рёбра графа в основном существенно длиннее ридов, а также уже проведена коррекция ошибок в самих ридах. Во-вторых, граф сборки даёт связи между рёбрами. Так как любой контиг это путь в графе, то можно попытаться исправить фрагмент контига, найдя подходящий путь между рёбрами, в местоположении которых в контиге мы уверены.

Итак, оказывается актуальной разработка нового инструмента, позволяющего исправлять ошибки в контигах при помощи графов сборки.

%==============================================================================
\section{Постановка задачи}
Целью данной работы является создание инструмента, позволяющего исправлять ошибки в контигах при помощи графов сборки. Для достижения этой цели были сформулированы следующие задачи.
\begin{itemize}
    \item Формирование критериев фильтрации выравниваний рёбер графа на последовательности.
    \item Разработка алгоритма исправления ошибок за пределами выравненных рёбер.
    \item Разработка алгоритма переноса полученных путей в графе обратно в последовательности.
    \item Реализация итогового алгоритма в виде отдельного инструмента.
    \item Апробация алгоритма на известных геномах.
\end{itemize}

%==============================================================================
\section{Обзор предметной области}
\subsection{Представление генома}
Большинство природных ДНК состоит из двух скрученных спиралей, к которым крепятся молекулы, называемые нуклеотидами \cite{art:Watson}. Всего в спиралях присутствует четыре вида нуклеотида: аденин (A), цитозин (C), гуанин (G), тимин (T). Двойная спираль ДНК может иметь либо линейную структуру, либо кольцевую. Одноцепочечную ДНК содержат лишь некоторые вирусы и бактериофаги. При этом известно, что одна спираль полностью задаёт другую: напротив каждого нуклеотида из одной цепочки стоит комплементарный ей из другой. Для аденина это тимин, а для гуанина --- цитозин.

Таким образом можно считать, что ДНК состоит из двух комплементарных строк над алфавитом из четырёх букв. Длину подстрок принято измерять в спаренных основаниях (англ. base pair, \textbf{bp}), которые эквивалентны одному символу строки.

\subsection{Секвенирование и сборка геномов}
Современные технологии не могут считывать всю ДНК за раз, поэтому в результате секвенирования получается множество фрагментов ДНК, называемых ридами. В зависимости от используемой технологии, длины ридов можно разделить на два класса: короткие и длинные. Короткие риды получают, в основном, при использовании технологии Illumina \cite{art:reads}, которая получает цепочки нуклеотидов порядка 100-200 bp. Длинные риды получают технологиями Pacbio и Oxford Nanopore \cite{art:reads}, которые получают цепочки порядка 10 и 100 kpb соответственно. Для сравнения, например, длина генома у бактерий измеряется в миллионах bp, у простых многоклеточных в сотнях миллионов bp, а у человека геном содержит около три миллиардов нуклеотидов.

К сожалению, при секвенировании происходят ошибки, поэтому ДНК читается несколько раз, чтобы в покрытии каждого нуклеотида результирующим набором ридов было больше правильных значений, чем ошибочных. В коротких ридах уровень ошибок составляет около 0.1-1\%, в то время как для длинных ридов это значение доходит до 10-15\% \cite{art:reads}.

Задачей ассемблера является восстановление одной из нитей спирали ДНК по ридам. Обычно удаётся  восстановить лишь фрагменты ДНК, которые являются либо контигами, либо скаффолдами. Их отличие в том, что в случае скаффолдов допускаются подстроки, в которых нуклеотиды неизвестны, что даёт дополнительную информацию в виде расстояния между контигами и их порядка следования в геноме.

Так как в коротких ридах мало ошибок, то достаточно небольшого покрытия генома ридами, чтобы граф, а следовательно и контиги, практически не содержали ошибки. Для длинных же ридов для достижения такого же результата покрытие должно быть большим, что иногда бывает просто невозможно получить, и к тому же дополнительные эксперименты стоят очень дорого.

\subsection{Граф сборки}
Методы сборки ридов в контиги далеко шагнули вперёд. В некоторых современных ассемблерах, таких как SPAdes \cite{art:SPAdes} и Flye \cite{art:flye}, используется подход, основанный на графе де Брюйна (англ. de Bruijn graph) \cite{art:Pevzner}. Этот граф строится по следующим принципам: берётся набор входных строк и выделяется из них множество всевозможных подстрок длины k+1 (k+1-меры). Тогда направленными рёбрами будут выступать k+1-меры. Вершинами же будут k-меры, полученные уже из k+1-меров и выступающие в роли перекрытия между ними. Соответственно, к вершине подсоединяются рёбра тем концом, который содержит k-мер вершины. Пример графа можно видеть на рисунке \ref{fig:debruijn}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{debruijn.png}
	\caption{Граф де Брюйна для строки ACGTCCGTAA с параметром ${k=2}$.}
	\label{fig:debruijn}
\end{figure}

Максимальное количество возможных вершин в графе де Брюйна равно $4^k$, а количество рёбер между ними --- $4^{k+1}$. При небольших значениях $k$ в графе, скорее всего, будут присутствовать почти все варианты вершин, а сам граф будет близок к полносвязному, что даёт плохое представление о геноме. С другой стороны, при больших $k$ граф может распасться на несвязные компоненты. Поэтому, например, ассемблер SPAdes проводит последовательно несколько сборок для разных $k$ и часто останавливается для запутанных геномов и метагеномов на значении 55.

Так как пути в графе де Брюйна образуют контиги, вершины, в которые входит и выходит ровно по одному ребру, можно удалить, объединив соответствующие рёбра в одно. Пример такого упрощения можно видеть на рисунке \ref{fig:debruijn_simpl}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.22]{debruijn_simpl.png}
	\caption{Граф сборки, полученный в результате упрощения графа с рисунка \ref{fig:debruijn}.}
	\label{fig:debruijn_simpl}
\end{figure}

Граф, полученный в результате упрощения графа де Брюйна, называется графом сборки. На самом деле, упрощение необходимо по нескольким причинам, которые описаны в работе \cite{art:disser_andrey}. В частности, это позволяет удалить рёбра, в которых содержатся ошибки.

\subsection{Выравнивание последовательностей}
Выравнивание последовательностей --- это процесс сопоставления символов одной строки символам другой так, чтобы чтобы максимизировать функцию похожести этих последовательностей. Если мы ожидаем, что последовательности небольшие и должны хорошо совпадать по всех свой длине, то в качестве функции похожести можно взять редакционное расстояние. Если известны какие-то особенности последовательностей, то лучше воспользоваться аффинным выравниванием (например, можно не штрафовать за большие несовпадающие участки). Находить точное значение функции требует количество действий, пропорциональное произведению длин, что для длинных строк неприемлемо, поэтому ограничиваются лишь приближёнными значениями.

Особенностью выравнивания ребер графа сборки на последовательность заключается в том, что ребро может соответствовать одновременно нескольким фрагментам последовательности, а также выравниваться лишь частично.

Помимо этого, существует задача выравнивания последовательности на целый граф сборки. В ней требуется найти \textit{путь} в графе, строковое представление которого максимально похоже на выравниваемую последовательность. 

\subsection{Инструменты для выравнивания последовательностей }

% \textbf{blat}

% \textbf{bwa}

\textbf{minimap2} \cite{art:minimap2} разрабатывался в ответ на появление технологий секвенирования, которые создают очень длинные риды (100 kbp в среднем). Его главное преимущество --- выравнивание длинных последовательностей DNA на большие референсные геномы более чем в 30 раз быстрее \cite{art:minimap2} по сравнению с существующими инструментами, при этом сохраняя достаточно высокий уровень точности.

\textbf{winnowmap} \cite{art:winnowmap} основывается на minimap2 и рассматривет проблему неравномерного распределения k-меров в геноме, уменьшая количество ложно-положительных совпадений. Однако впоследствии его идеи были включены в последние версии minimap2.

\textbf{GraphAligner} \cite{art:rautiainen2020graphaligner} основывается на идее выравнивание последовательности на граф на основе битового параллелизма \cite{art:bpstga}. Основное преимущество --- выравнивание в 12 раз быстрее и в 2 раза точнее по сравнению с существующими инструментами \cite{art:rautiainen2020graphaligner}. Помимо этого, полезной возможностью является нахождения не одного лучшего выравнивания, а сразу нескольких.

% \textbf{SPAligner} \cite{art:spaligner} основывается 

\subsection{Существующие решения}
\textbf{LoRDEC} \cite{art:salmela2014lordec} был первым, кто использовал граф де Брюйна, построенный из коротких ридов, в качестве индекса для исправления длинных ридов. В LoRDEC длинные риды привязывались к графу, используя общие k-меры. Затем непривязанные подпоследовательности исправлялись с помощью путей, которые похожи на исправляемые подпоследовательности. Многие инструменты для гибридного исправления ошибок в длинных ридах основываются на этом подходе LoRDEC.

\textbf{Jabba} \cite{art:miclotte2016jabba}, помимо использования подхода LoRDEC, перед построением графа применяет самокоррекцию коротких ридов. Кроме этого, длинные риды привязываются к графу, используя максимально точные совпадения, чтобы использовать k-меры разной длины во время исправления ошибок.

\textbf{HG-CoLoR} \cite{art:morisse2018hybrid} также применяет самокоррекцию коротких ридов, а также выравнивает их на длинные риды, чтобы найти перекрытия между собой. Эти перекрытия привязывают риды к графу де Брюйна переменного порядка с учётом разных длин k-меров.

\textbf{FMLRC} \cite{art:wang2018fmlrc} индексирует граф де Брюйна, используя многострочное преобразование Барроуза — Уилера (англ. multi-string Burrows-Wheeler Transform) коротких ридов. Это представление занимает мало места в памяти, допускает несколько длин k-меров и неявно сохраняет частоту появления k-меров. Исправление ошибок в FMLRC происходит в два прохода: во время первого используется небольшое значение k для k-меров, в то время как для второго используется k больше, чтобы упростить граф в особо сложных местах.

\textbf{CoLoRMap} \cite{art:haghshenas2016colormap}, в отличии от вышеупомянутых инструментов, строит граф взвешенных выравниваний из сопоставления коротких ридов длинным. Это сопоставление позволяет получить пути в графе, которые максимально похожи на подпоследовательности исправляемых последовательностей. CoLoRMap использует информацию о парных концах коротких ридов, чтобы перепрыгнуть регионы длинных ридов, которым не сопоставлен ни один короткий рид.

\textbf{Ratatosk} \cite{art:holley2021ratatosk} в свою очередь, во первых, раскрашивает вершины графа де Брюйна с помощью коротких и длинных ридов, чтобы выделить существующие пути для исправления. Раскраска графа позволяет уменьшить пространство обхода графа, удаляя химерные пути.
Во вторых, длинные риды привязываются к графу, используя как точное совпадение k-меров, так и неточное, что позволяет привязать регионы с большим количеством ошибок. В третьих, граф аннотируется кандидатами на точечные ошибки в один нуклеотид, что позволяет выделить небольшие вариации между гаплотипами, которые трудно уловить из ошибочных длинных ридов. В четвёртых, коррекция выполняется в два прохода, используя короткие и длинные риды по отдельности.

Для получения большей информации об исправлении ошибок в длинных ридах можно воспользоваться обзорами \cite{art:morisse2020long, art:zook2016extensive, art:zhang2020comprehensive}.

\subsection{Оценка качества сборки}
Для того чтобы понять, насколько результат сборки соответствует реальному геному, существует много метрик. Одни можно вычислить только по результату сборки, другие же требуют наличие референсного генома --- некоторого эталонного генома для данного вида организма. Метрики, использующие референсный геном, позволяют намного детальнее оценить качество сборки. Стоит отметить, что собранный геном не должен полностью совпадать с референсным геномом, так как геном исследуемого организма может отличаться от эталонного на 1-2\%.

Одной из программ, позволяющих вычислять оба вида метрик, является QUAST \cite{art:QUAST}. Помимо одиночных геномов он также поддерживает использование  метагеномов для оценки качества сборки как отдельных геномов в него входящих, так и их объединения \cite{art:metaquast}.

%==============================================================================
\section{[TODO: fix constants uses] Алгоритм}

Представленный в данной работе алгоритм является эвристическим. Все приведённые точные значения являются параметрами алгоритма по-умолчанию и были получены как оптимальные при тестировании на различных данных.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[
    every node/.style={
      draw=black,
      anchor=west,
      minimum height=1cm,
      rounded corners 
      }, 
    font=\small
    ]
    \begin{scope}[on grid]
    \node[ellipse, inner sep=0pt] (graph)               {граф сборки};
    \node (align) [left = 2cm of graph.west] {1. выравнивание рёбер графа на последовательности};
    \node[draw=purple] (filter) [below  right = 2cm and 7cm of align] {2. фильтрация выравниваний};
    \node[draw=purple, align=left] (filling) [below = 2cm of filter] {3. нахождение и смешивание путей \\ между выравниваниями};
    \node[draw=purple] (write back) [left = 1cm of filling.west] {4. перенос путей в последовательности};
    \node[ellipse, inner sep=0pt] (seq)  [above = 2cm of write back] {зашумлённые последовательности};
    \end{scope}

    \path[->]
    (align) edge (filter)
    (filter) edge (filling)
    (filling) edge (write back)
    ;
    \path[->, dashed]
    (graph) edge (align) edge [bend left=54] (filling)
    (seq) edge (align) edge (filling) edge (write back)
    ;
\end{tikzpicture}
\caption{Алгоритм коррекции. Фиолетовым цветом обозначены стадии, описанные в данной работе. Пунктирными стрелочками --- использование данных.}
\label{fig:pipeline}
\end{figure}

Алгоритм коррекции состоит из следующей последовательности шагов, изображённых на рисунке \ref{fig:pipeline}.
\begin{enumerate}
    \item Рёбра графа сборки выравниваются на исправляемые последовательности с помощью какого-нибудь выравнивателя. Так как в графе уже присутствуют как прямые рёбра, так и обратно-комплементарные, необходимо получить выравнивания рёбер только в их прямом направлении. Кроме того, так как в графе есть неуникальные рёбра (например, отражают повтор в геноме или принадлежат нескольким организмам в метагеноме), необходимо получить все выравнивания ребра, которые нашёл выравниватель, а не только одно наилучшее.
    \item Найденных выравниваний довольно много, они перекрывают друг друга, и далеко не все из них действительно должны находиться на найденных местах (например, повторы). Поэтому их нужно отфильтровать. Те выравнивания рёбер, что останутся, будем называть \textit{якорями}.
    \item Помимо исправления последовательностей непосредственно якорями, нужно исправлять и другие места. Для этого между якорями находятся пути, которые затем смешиваются для получения строки, которая заменит фрагмент последовательности между этими якорями. Будем называть такие строки \textit{строками-заменителями}. Якоря со строками-заменителями между ними образуют \textit{смешанный путь} в графе.
    \item Полученные смешанные пути переносятся в исправляемые последовательности.
\end{enumerate}

\subsection{Выбор якорей}
Из множества всех найденных выравниваний на рёбра графа нас интересуют те, которые ``скорее всего'' находятся на правильном месте. Так, например, с увеличением длины ребра, вероятность, что оно будет выравнено на множество мест, уменьшается.

Для выбора якорей используются два фильтра: грубый (англ. rough) и точный (англ. fine). Грубый фильтр работает на этапе чтения выравниваний и оценивает их правильность в отрыве от остальных выравниваний посредством следующих критериев:
\begin{itemize}
    \item длина выравнивания (а значит и длина ребра) больше минимальной разрешённой длины ($300$ символов);
    \item выравненные фрагмент последовательности и фрагмента ребра совпадают хотя бы на половину, то есть их идентичность\footnote{Отношение удвоенного количества совпавших символов к сумме длин сопоставленных подстрок.} (англ. identity) $> 50\%$;
    \item разница длин выравненных фрагмента последовательности и фрагмента ребра не превышает ожидаемого уровня ошибочности сборки, что на практике бывает около $5\%$;
    \item выравнивание является одним из случаев:
    \begin{itemize}
        \item ребро полностью содержится в последовательности;
        \item последовательность полностью содержится в ребре;
        \item конец ребра является началом последовательности;
        \item начало ребра является концом последовательности\footnote{Часто ``конец/начало ребра/последовательности'' не является суффиксом/префиксом из-за наличия ошибок, поэтому необходимо допускать небольшой отступ, например, не больше $k$ символов.};
        \item выравнялась лишь часть ребра, но она достаточно длинная ($\ge 2000$ символов), чтобы можно было считать это структурным отличием графа от последовательности;
    \end{itemize}
\end{itemize}

Точный фильтр оценивает правильность выравнивания на основе уникальности. Выравнивание считается \textit{уникальным}, если его ребро имеет не больше одного выравнивания, которое полностью содержится в какой-либо последовательности. Выравнивание принимается точным фильтром, если оно:
\begin{itemize}
    \item длинное и уникальное;
    \item короткое, уникальное и идентичность выше $70\%$.
    \item неуникально и идентичность выше $90\%$.
\end{itemize}

Оставшиеся после фильтрации выравнивания рёбер будем называть \textit{якорями}. 

Для каждого якоря определяется уровень достоверности:
\begin{enumerate}
    \item высокий: якорь уникальный;
    \item средний: якорь неуникальный и средней длины ($\ge 1000$ символов);
    \item низкий: оставшиеся якоря;
\end{enumerate}

После фильтрации якоря потенциально всё ещё могут быть взаимоисключающими (то есть пересекаться больше, чем на $k$\footnote{Количество символов пересечения смежных рёбер в графе}$+\varepsilon$\footnote{Несколько символов для возможных ошибок, например, $5$}). Взаимоисключающие рёбра отбрасываются следующим образом:
\begin{itemize}
    \item для каждой пары якорей проверяется, конфликтуют ли они. Если да, то:
    \begin{itemize}
        \item если у них разные уровни достоверности, то на удаление помечается тот, что с меньшим;
        \item если уровни достоверности одинаковые и длины якорей отличаются больше, чем в два раза, то помечается тот, что с меньшей;
        \item иначе помечаются оба;
    \end{itemize}
    \item все помеченные якоря разом отбрасываются;
\end{itemize}

Тем не менее, критериев фильтрации на практике оказывается достаточно, чтобы взаимоисключающих рёбер было не больше всего нескольких единиц из класса с низким уровнем достоверности.

\subsection{Пути между якорями}
Расположим якоря в порядке встречи их в последовательности. Заполнение пространства вне якорей проходит следующим образом.
\begin{itemize}
    \item Для каждой пары смежных якорей самого достоверного класса находятся пути в графе, которые отличаются не больше, чем на $10\%$ от длины фрагмента последовательности между этими якорями. Найденные пути затем и смешиваются и формируют строки-заменители.
    \item Если между двумя якорями не было сформировано строк-заменителей, то в этот промежуток добавляются якоря из следующего класса достоверности и процесс поиска-смешивания-формирования повторяется.
\end{itemize}

Между якорями ищутся все пути, чтобы на этапе смешивания быть уверенным, что различия между гаплотипами не будут потеряны. Так как графы устроены довольно сложно, путей даже между не очень удалёнными якорями (несколько тысяч символов) может быть чрезвычайно много (десятки и сотни тысяч), то поиск имеет несколько ограничений, выход за которые, как показывает наша практика, не имеет смысла. Сам поиск проходит в два этапа.
\begin{enumerate}
    \item С помощью алгоритма Дейкстры в графе помечаются все вершины, через которые существует путь с заданным ограничением сверху на длину. Количество найденных вершин не должно превышать 3000.
    \item Поиском в глубину по помеченным вершинам выбираются все пути с заданными ограничениями на длину. При этом суммарное количество рекурсивных вызовов не должно превышать 3000, а если оно превысило 500, то дополнительно проверяется, чтобы в найденном пути было не больше 5 одинаковых рёбер.
\end{enumerate}
Если поиск обнаружил превышение данных ограничений, процесс получения строки-заполнителя между текущей парой якорей прерывается. Эти ограничения выбраны таким образом, чтобы большинство случаев поиска завершалось с большим запасом до их превышения, но на слишком запутанных частях графа они быстро прерывались.

\subsection{Смешивание путей}
После того, как все пути между якорями найдены, необходимо понять, что из этого может исправить последовательность, а что испортить. 
Для этого каждый путь выравнивается на фрагмент последовательности. Если расстояние между ними слишком велико, то этот путь отбрасывается. Часть с выравниванием является самой трудоёмкой частью всего пайплайна коррекции и занимает больше $95\%$ времени, поэтому происходит параллельно.

Оставшиеся пути упорядочиваются в порядке возрастания расстояния. Если остался всего один путь, или у первого пути расстояние существенно\footnote{Довольно часто лучшие пути имеют расстояние 0-5, что является несущественным отличием, чтобы однозначно сказать, что какой-то путь лучше. Поэтому, помимо процентного соотношения (в два раза), стоит использовать и абсолютный порог (на десять).} меньше, чем у второго, то этот путь становится \textit{кандидатом} на строку-заменитель.

Не каждый кандидат становится строкой-заменителем. Чтобы это произошло, он должен отличаться от фрагмента последовательности не больше, чем среднее количество ошибок в текущей последовательности (это значение вычисляется после выбора якорей на основании их среднего значения идентичности).

Довольно часто все найденные пути являются порождением подграфа, который представляет из себя набор ``пузырей'' (альтернатив из двух подпутей), например, как на рисунке \ref{fig:buldges}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{buldges.png}
    \caption{Подграф, содержащий два ``пузыря'': (x, x') и (y, uv).}
    \label{fig:buldges}
\end{figure}

Пузыри зачастую образуются в результате наличия повторов в геноме, или когда есть похожие фрагменты у двух организмов (например, двух штаммах бактерии) в метагеноме. Рёбра в них отличаются весьма слабо, поэтому, если разложить такой подграф на два пути (с рисунка \ref{fig:buldges} это $axbyc$ и $ax'buvc$), можно выравнять эти пути между собой, найти места, которые в них отличаются, и заменить их на фрагменты из исправляемой последовательности. Таким образом вариации между гаплотипами будут сохранены, а ошибки исправлены. Полученная строка является также лишь кандидатом на строку-заменитель, чтобы избежать случайного внесения большого количества ошибок в последовательность.

Попытка сжатие пути до двух происходит следующим образом.  Сначала строится вспомогательный ориентированный граф. Для этого каждое ребро каждого пути представляются парой: id ребра и порядковый номер его вхождения в этот путь. Эти пары становятся вершинами в новом графе. Если два ребра стоят подряд в пути, то в новом графе между соответствующими им парами будет ребро. Пример на рисунке \ref{fig:compresed_paths}.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[every node/.style={circle,draw=black}]
    \begin{scope}[on grid]
    \node (a0)               {$a,0$};
    \node (x)  [below right=1cm and 2.25cm of a0] {$x,0$};
    \node (y)  [right=2.5cm of x ] {$y,0$};
    \node (b)  [above right=1cm and 3.5cm of a0] {$b,0$};
    \node (a1) [above right=1cm and 2.25cm of y]  {$a,1$};
    \node (g0) [above right=1cm and 2.25cm of a1] {$g,0$};
    \node (g1) [right=2.5cm of g0] {$g,1$};
    \node (c)  [below right=1cm and 3.5cm of a1] {$c,0$};
    \node (d)  [below right=1cm and 2.25cm of g1] {$d,0$};
    \end{scope}

    \path[->]
    (a0) edge (b) edge (x)
    (b) edge (a1)
    (x) edge (y)
    (y) edge (a1)
    (a1) edge (g0) edge (c)
    (g0) edge (g1)
    (g1) edge (d)
    (c) edge (d)
    ;
\end{tikzpicture}
\caption{Пример сжатия четырёх путей (каждая буква является ребром пути): $abacd$, $abaggd$, $axyacd$, $axyaggd$. Первый путь даёт вершины $(a,0)$, $(b,0)$, $(a,1)$, $(c,0)$, $(d,0)$ и соединения между ними. Для остальных путей аналогично.}
\label{fig:compresed_paths}
\end{figure}

При и после построения вспомогательного графа проверяется его корректность: 
\begin{itemize}
    \item нет циклов и петель;
    \item начальные и конечные вершины совпадают с начальными и конечными вершинами каждого из путей;
    \item у каждой общей вершины не больше двух входящих и двух исходящих рёбер;
    \item у каждой вершины из альтернатив ровно по одному входящему и исходящему ребру;
\end{itemize}

Если граф получился корректным, то получаем два пути: первый состоит из общих вершин и первых альтернатив, а второй --- из общих вершин и вторых альтернатив. Если же корректность нарушена, то сжать пути не удалось и между текущими двумя якорями последовательность исправлена не будет.

Несмотря на то, что есть примеры, когда пути сжать можно, но он этого не делает (например, $aaa$ и $aba$), на практике этого алгоритма достаточно, чтобы сжать почти все подходящие наборы путей.

\subsection{Перенос путей в последовательность}
После того, как будут получены строки-заменители, их необходимо разместить обратно в исправляемую последовательность. Для определения фрагмента последовательности, соответствующего данной строке, используются выравнивания с первого шага алгоритма --- это диапазон с позиции первого символа первого якоря в составе строки до позиции последнего символа в последнем якоре в составе строки. Стоит отметить, что диапазоны строк-заменителей могут пересекаться вплоть до $k+\varepsilon$, при этом символы в перекрытии могут не совпадать. Чтобы избежать внесения ошибок, эти конфликты решаются следующим образом. Обозначим за $a$ и $b$ фрагменты перекрытия, соответствующие первой и второй строкам-заменителям, а за $s$ соответствующий фрагмент последовательности. Тогда:
\begin{enumerate}
    \item если $a=b$, то выбирается $a$;
    \item если $a=s$ или $b=s$, то выбирается $s$;
    \item в противном случае также выбирается $s$;
\end{enumerate}
Для 3его случая можно воспользоваться смешиванием из предыдущего шага, тем самым исправляя общие символы и не меняя несовпадающие, но на практике таких случаев обычно всего несколько штук на сборку, поэтому если ошибки и останутся неисправленным, то в пренебрежимо малом количестве.

\subsection{[TODO] Архитектура решения}


%==============================================================================
\section{Альтернативный алгоритм}
Можно заметить, что решение довольно похоже на решение задачи выравнивания последовательностей на граф (т.е. нахождение как можно более длинных путей в графе, которые соответствуют фрагментам последовательностей). Кажется, что отличие лишь в том, что мы дополнительно по-умному смешиваем пути между якорями на уровне нуклеотидов. Рассмотрим альтернативный алгоритм:
\begin{enumerate}
    \item взять существующий выравниватель на граф;
    \item взять несколько лучших выравниваний для каждого фрагмента последовательности;
    \item смешать найденные пути;
\end{enumerate}

\subsection{Кластеризация}
\begin{sloppypar}
Для проверки данного алгоритма был взят выравниватель GraphAligner. Он уже выдаёт несколько лучших найденных выравниваний для каждой области последовательности. Так как пути покрывают похожие, но не идентичные фрагменты, нужно разбить пути на кластера, которые будут покрывать как можно больше длины последовательности, и как можно меньше пересекаться (т.е. конфликтовать) друг с другом. Для этого будем последовательно объединять пути в кластера по следующему критерию: если два пути перекрываются выравниваниями больше, чем на $70\%$, то они лежат в одном кластере. Как показывает практика, на наших тестах этого критерия было достаточно, чтобы лучшие по идентичности пути в кластерах покрывали последовательность на $95-100\%$, все пути в кластере попарно пересекались минимум на $70\%$, а пути различных кластеров практически не пересекались ($<1\%$).
\end{sloppypar}

\subsection{Смешивание}
Пути в полученных кластерах смешиваются следующим образом.
\begin{enumerate}
    \item Выбирается лучший путь в кластере по идентичности с последовательностью.
    \item Все остальные пути выравниваются на лучший.
    \item По полученным выравниваниям помечаем символы и позиции между символами лучшего пути помечаются недостоверными, если хотя бы в одном выравнивании есть отличие.
    \item Недостоверные места заменяются символами из последовательности.
\end{enumerate}

Полученные после смешения строки переносятся обратно способом, описанным главе ``Перенос путей в последовательность''.

%==============================================================================

\section{Апробация}
В данной главе будет приведён сравнительный анализ реализации описанного в даной работе алгоритма на синтетических и настоящих метагеномах как с существующими решениями, так и с альтернативным алгоритмом.

\subsection{Метрики}
Сравнение качества коррекции начинается с выравнивания исправленных последовательностей на референсный геном. После этого для общих фрагментов используются следующие метрики:
\begin{itemize}
    \item \textit{количество замен} --- количество \textbf{символов} в выравнивании, в которых нуклеотиды последовательности не совпадают с сопоставленными им нуклеотидами референсного генома;
    \item \textit{количество вставок и удалений} --- количество \textbf{непрерывных участков} в выравнивании, которые присутствуют либо только в последовательностях, либо только в выравненной части референсного геноме;
    \item \textit{количество замен на 100 kbp} --- среднее количество замен на 100 kbp;
    \item \textit{количество вставок и удалений на 100 kbp} --- среднее количество вставок и удалений на 100 kbp;
    \item \textit{покрытие генома} --- процент нуклеотидов референсного генома, которые покрыты контигами;
    \item \textit{количество структурных ошибок} --- количество релокаций, инверсий, транслокаций. Пример изображён на рисунке \ref{fig:miss};
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{misassemblies.png}
    \caption{Дан контиг, состоящий из двух частей, расположение которых при сопоставлении с референсным геномом определяет тип структурной ошибки.}
    \label{fig:miss}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{alignment.eps}
    \caption{Пример выравнивания строк AAAAAAGTGGTTGATGGTT и GTGTTCCTGATACTTTTTT. Серым цветом выделены невыравненные фрагменты. Зелёным --- совпавшие фрагменты. Красным --- замены. Жёлтым --- вставки и удаления. }
    \label{fig:alignment}
\end{figure}

\subsection{[TODO] Схема сравнения}
На рисунке \ref{fig:common_pipeline} показана общая схема проведения сборки раздельно из длинных и коротких ридов.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[
    every node/.style={
      draw=black,
      anchor=west,
      minimum height=1cm,
      align=center,
      rounded corners 
      }, 
    font=\small
    ]
    \begin{scope}[on grid]

        \node (cor1) {коррекция длинных\\ридов};
        \node (assembly) [right = 1cm of cor1.east] {сборка из длинных\\ридов};
        \node (cor2) [right = 1cm of assembly.east] {коррекция контигов сборки\\из длинных ридов};
        \node[ellipse, inner sep=0pt] (long reads) [above = 2cm of cor1] {длинные риды};
        \node[ellipse, inner sep=0pt] (graph) [above right = 2cm and 2cm of assembly] {граф сборки из коротких ридов};

    \end{scope}

    \path[->]
    (cor1) edge (assembly)
    (assembly) edge (cor2)
    ;
    \path[->, dashed]
    (long reads) edge (cor1)
    (graph) edge (cor1) edge (cor2)
    ;
\end{tikzpicture}
\caption{Процесс раздельной сборки из коротких и длинных ридов начинается с получения графа сборки. Затем, опционально, длинные риды можно подвергнуть коррекции, после чего из них происходит непосредственно сборка генома, контиги которой также можно опционально попытаться исправить.}
\label{fig:common_pipeline}
\end{figure}

В ходе апробации используются следующие три варианта сравнения:
\begin{itemize}
    \item применяется коррекция только длинных ридов;
    \item применяется коррекция только контигов;
    \item применяется коррекция как длинных ридов, так и контигов;
\end{itemize}

Среди инструментов, которые исправляют длинные риды при помощи коротких ридов, последним вышедшим (2021 г.) и одним из лучших является Ratatosk \cite{art:holley2021ratatosk, art:zhang2020comprehensive, art:fu2019comparative}, поэтому сравнительный анализ будет приведён именно с ним.

Стоит отметить, что реализованный в данной работе алгоритм применяется только для коррекции контигов сборки, так как каждый фрагмент генома в среднем покрывается лишь одним контигом, что неверно для ридов. Из-за этого описанная в разделе "выбор якорей" оценка уникальности выравниваний будет работать некорректно.

Во всех тестах граф сборки из коротких ридов получен ассемблером SPAdes. Для сборки из длинных ридов использовался ассемблер Flye. Инструментом для сбора метрик и сравнения является Quast.

\subsection{[TODO: fix metrics] Сравнение с основным алгоритмом }
В данном разделе приводится сравнение двух алгоритмов, представленных в работе. Тестирование проводилось на метагеноме Zymo.

Столбцы на рисунках \ref{fig:indels_ga} и \ref{fig:mismatches_ga}:
\begin{enumerate}
    \item бактерии, входящие в состав метагенома;
    \item контиги Flye без коррекции;
    \item контиги после коррекции основным алгоритмом;
    \item контиги после коррекции альтернативным алгоритмом;
    \item контиги после коррекции альтернативным алгоритмом с той лишь разницей, что после выбора лучшего пути смешения с остальными не происходит;
\end{enumerate}

\begin{figure}[h]
    \centering
    \include{tables/mix.mismatches.tex}
    \caption{Замены}
    \label{fig:mismatches_ga}
\end{figure}

\begin{figure}[h]
    \centering
    \include{tables/mix.indels.tex}
    \caption{Вставки и удаления}
    \label{fig:indels_ga}
\end{figure}

По вставкам и удалениям альтернативный алгоритм местами существенно обходит основной.

По количеству замен альтернативный алгоритм не только проигрывает основному алгоритму, но и в половине случаев вносит ошибок больше, чем исправляет. Особое внимание стоит обратить на бактерию Salmonella Enterica, для неё пути GraphAligner прошлись по похожим рёбрам другой бактерии, что привело к всплеску замен.


\subsection{[TODO] Симулированные метагеномы}
\begin{figure}[h]
    \centering
    \include{tables/base20.mismatches.tex}
    \caption{Замены base20}
    \label{fig:mismatches_base20_onto}
\end{figure}

\begin{figure}[h]
    \centering
    \include{tables/base20.indels.tex}
    \caption{Вставки и удаления base20}
    \label{fig:indels_base20_onto}
\end{figure}

\subsection{[TODO] Настоящие метагеномы}
\begin{figure}[h]
    \centering
    \include{tables/bmock12.mismatches.tex}
    \caption{Замены}
    \label{fig:mismatches_bmock12}
\end{figure}

\begin{figure}[h]
    \centering
    \include{tables/bmock12.indels.tex}
    \caption{Вставки и удаления}
    \label{fig:indels_bmock12}
\end{figure}

\begin{figure}[h]
    \centering
    \include{tables/zymo.mismatches.tex}
    \caption{Замены}
    \label{fig:mismatches_zymo}
\end{figure}

\begin{figure}[h]
    \centering
    \include{tables/zymo.indels.tex}
    \caption{Вставки и удаления}
    \label{fig:indels_zymo}
\end{figure}

%==============================================================================
%% У заключения нет номера главы
% \newpage
% \[\]
\newpage
\section*{Заключение}
В ходе данной работы были получены следующие результаты.
\begin{itemize}
    \item Сформированы критерии фильтрации выравниваний рёбер графа на последовательности.
    \item Разработан алгоритм исправления ошибок за пределами выравненных рёбер.
    \item Разработан алгоритм переноса полученных путей в графе обратно в последовательности.
    \item Итоговый алгоритм реализован в виде отдельного инструмента.
    \begin{itemize}
        \item Реализация выполнена на языке C++ и является подпроектом для ассемблера SPAdes.
        \item \begin{sloppypar} Исходный код SPAdes доступен по ссылке: \mbox{\url{https://github.com/ablab/spades/}}. Реализованный инструмент будет доступен начиная с версии 3.17. \end{sloppypar}
    \end{itemize}
    \item Проведена апробация на известных геномах.
    \begin{itemize}
        \item Исправления метагеномных сборок низкого качества даёт сравнимый и лучший результат по сравнению с коррекцией ридов и сборок существующими решениями.
        \item Кооперация с существующими решениями даёт существенно лучший результат.
    \end{itemize}

\end{itemize}

%==============================================================================

\section*{Глоссарий}

\textbf{Ассемблер} --- программное обеспечение для получение контигов и скаффолдов из ридов.\\

\textbf{Граф де Брюйна} --- граф с параметром k, в котором рёбрами являются все возможные подстрок длины k+1 из некоторого набора строк, а вершинами --- перекрытия этих подстрок в k позициях.\\

\textbf{Граф сборки} --- в этой работе: граф, полученный в результате упрощения графа де Брюйна.\\

\textbf{К-мер} --- последовательность длины К.\\

%\textbf{Покрывающий путь} --- путь, проходящий через заданное ребро.\\

%\textbf{Плазмиды} --- небольшие молекулы ДНК, физически отделённые от хромосом.\\

\textbf{Референсный геном} --- эталонный геном данного вида организма.\\

\textbf{Риды} --- множество фрагментов ДНК, которые получаются в результате секвенирования.\\

\textbf{Контиги} --- восстановленные части ДНК из ридов.\\

\textbf{Скаффолд} --- объединение нескольких контигов с известным расстоянием между ними, но неизвестными самими нуклеотидами.\\

%==============================================================================

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma}
\end{document}
