% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Программная инженерия\\Системное программирование},
    title              = {Исправление ошибок в зашумленных последовательностях при помощи графов сборки},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = 444,
    author             = {Клещин Антон Сергеевич},
    supervisorPosition = {доц. каф. СП, к. т. н.},
    supervisor         = {Литвинов Ю.\,В.},
    supervisorPositionx   = {доц. каф. стат. мод., к. ф.-м. н.},
    supervisorx           = {Коробейников А.\,И.},
    supervisorPositiony   = {старший н. с., к. ф.-м. н.},
    supervisory           = {Пржибельский А.\,Д.},
    reviewerPosition  = {приглашённый н. с., к. ф.-м. н.},
    reviewer          = {Нурк С.\,Ю.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Software and Administration of Information Systems \\ Software Engineering},
    title              = {Error correction in noisy sequences using assembly graphs},
    type               = {master},
    author             = {Anton Kleshchin},
    supervisorPosition = {C.Sc., Associate Professor},
    supervisor         = {Yurii Litvinov},
    supervisorPositionx   = {Ph.D., Associate Professor},
    supervisorx           = {Anton Korobeynikov},
    supervisorPositiony   = {Ph.D., Senior Research Fellow},
    supervisory           = {Andrey Prjibelski},
    reviewerPosition  = {Ph.D., Visiting Fellow},
    reviewer          = {Sergey Nurk},
}
\maketitle
\tableofcontents
\setcounter{secnumdepth}{4}
%==============================================================================
% У введения нет номера главы
\section*{Введение}
Сборка геномов является одной из важнейших задач биоинформатики. За многие годы учёным уже удалось собрать, а затем и расшифровать большое количество геномов. Несмотря на это, автоматическая реконструкция генома всё ещё остаётся сложной вычислительной задачей \cite{sohn2018present, art:collins2018challenge}.

Обычно сборка генома происходит из ридов (англ. reads) --- фрагментов ДНК, которые получаются в результате секвенирования, а результатом являются контиги (англ. contigs, восстановленные части ДНК из ридов) или скаффолды (англ. scaffolds, восстановленные части ДНК с пропусками известной длины).

Технологии секвенирования не стоят на месте: появилось третье поколение, позволяющие получать длинные риды дешевле, но количество ошибок в них на порядок выше \cite{art:reads}. Несмотря на то, что есть способы частично бороться с этими ошибками \cite{art:alic2016objective}, для улучшения результатов сборки можно прибегнуть к другим методам. Например, для небольших геномов активно применяется метод гибридной сборки \cite{art:hybridSpades, art:zimin2013masurca, art:wick2017unicycler}, в которой одновременно используются как длинные риды с большим количеством ошибок, так и короткие, уровень ошибок в которых минимален. Короткие риды здесь выступают основным материалом для построения графа сборки, а длинные риды позволяют находить более длинные пути в этом графе, которые в дальнейшем становятся контигами.

Кроме того, даже с небольшими геномами есть проблемы. Например, есть штаммы бактерий, получить большое количество экземпляров которых крайне сложно. В этом случае покрытие генома полученными ридами оказывается очень низким, как и качество длинных ридов. Более того, некоторые штаммы вообще невозможно получить без окружающих их бактерий, поэтому прибегают к метагеномике --- направлению геномики, в котором рассматриваются ДНК не отдельного организма, а сразу множества. Покрытие ридами генома каждой бактерии в рамках одной сборки может сильно отличаться, что только ухудшает качество контигов бактерий с низким покрытием.

Уже существуют инструменты, которые стараются исправлять контиги, используя риды. Их основная идея --- найти выравнивания ридов на контиги и с помощью какого-нибудь алгоритма консенсуса решить, какие нуклеотиды исправлять. При этом подходе теряется информация, которую нам даёт граф сборки. Во-первых, рёбра графа в основном существенно длиннее ридов, а также уже проведена коррекция ошибок в самих ридах. Во-вторых, граф сборки даёт связи между рёбрами. Так как любой контиг это путь в графе, то можно попытаться исправить фрагмент контига, найдя подходящий путь между рёбрами, в местоположении которых в контиге мы уверены.

Итак, оказывается актуальной разработка нового инструмента, позволяющего исправлять ошибки в контигах при помощи графов сборки.

%==============================================================================
\section{Постановка задачи}
Целью данной работы является создание инструмента, позволяющего исправлять ошибки в контигах при помощи графов сборки. Для достижения этой цели были сформулированы следующие задачи.
\begin{itemize}
    \item Формирование критериев фильтрации выравниваний рёбер графа на последовательности.
    \item Разработка алгоритма исправления ошибок за пределами выравненных рёбер с помощью путей в графе.
    \item Разработка алгоритма переноса полученных путей в графе обратно в последовательности.
    \item Реализация итогового алгоритма в виде отдельного инструмента.
    \item Апробация алгоритма на симулированных и реальных данных.
\end{itemize}

%==============================================================================
\section{Обзор предметной области}
\subsection{Представление генома}
Большинство природных ДНК состоит из двух скрученных спиралей, к которым крепятся молекулы, называемые нуклеотидами \cite{art:Watson}. Всего в спиралях присутствует четыре вида нуклеотида: аденин (A), цитозин (C), гуанин (G), тимин (T). Двойная спираль ДНК может иметь либо линейную структуру, либо кольцевую. Одноцепочечную ДНК содержат лишь некоторые вирусы и бактериофаги. При этом известно, что одна спираль полностью задаёт другую: напротив каждого нуклеотида из одной цепочки стоит комплементарный ей из другой. Для аденина это тимин, а для гуанина --- цитозин.

Таким образом можно считать, что ДНК состоит из двух комплементарных строк над алфавитом из четырёх букв. Длину подстрок принято измерять в спаренных основаниях (англ. base pair, \textbf{bp}), которые эквивалентны одному символу строки.

\subsection{Секвенирование и сборка геномов}
Современные технологии не могут считывать всю ДНК за раз, поэтому в результате секвенирования получается множество фрагментов ДНК, называемых ридами. В зависимости от используемой технологии, длины ридов можно разделить на два класса: короткие и длинные. Короткие риды получают, в основном, при использовании технологии Illumina \cite{art:reads}, которая получает цепочки нуклеотидов порядка 100-350 bp. Длинные риды получают технологиями Pacbio и Oxford Nanopore \cite{art:reads}, которые получают цепочки порядка 5-100 kbp и 10-1000 kpb соответственно. Для сравнения, например, длина генома у бактерий измеряется в миллионах bp, у простых многоклеточных в сотнях миллионов bp, а у человека геном содержит около трёх миллиардов нуклеотидов.

К сожалению, при секвенировании происходят ошибки, поэтому ДНК читается несколько раз, чтобы в покрытии каждого нуклеотида результирующим набором ридов было больше правильных значений, чем ошибочных. В коротких ридах уровень ошибок составляет около 0.1-1\%, в то время как для длинных ридов это значение доходит до 10-15\% \cite{art:reads}.

Задачей ассемблера является восстановление одной из нитей спирали ДНК по ридам. Обычно удаётся  восстановить лишь фрагменты ДНК, которые являются либо контигами, либо скаффолдами. Их отличие в том, что в случае скаффолдов допускаются подстроки, в которых нуклеотиды неизвестны, что даёт дополнительную информацию в виде расстояния между контигами и их порядка следования в геноме.

Так как в коротких ридах мало ошибок, то достаточно небольшого покрытия генома ридами, чтобы граф, а следовательно и контиги, практически не содержали ошибки. Для длинных же ридов для достижения такого же результата покрытие должно быть большим, что иногда бывает просто невозможно получить, и к тому же дополнительные эксперименты стоят очень дорого.

\subsection{Граф сборки}
Методы сборки ридов в контиги далеко шагнули вперёд. В некоторых современных ассемблерах, таких как SPAdes \cite{art:SPAdes}, Velvet \cite{art:zerbino2008velvet}, RAY \cite{art:boisvert2010ray}, ABySS \cite{art:simpson2009abyss}, IDBA-UD \cite{art:peng2012idba}, SKESA \cite{art:souvorov2018skesa}, используется подход, основанный на графе де Брюйна (англ. de Bruijn graph) \cite{art:Pevzner}. Этот граф строится по следующим принципам: берётся набор входных строк и выделяется из них множество всевозможных подстрок длины k+1 (k+1-меры). Тогда k+1-мер --- это ребро, ведущее из своего префикса длины k в суффикс длины k. Пример графа можно видеть на рисунке \ref{fig:debruijn}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{debruijn.png}
	\caption{Граф де Брюйна для строки ACGTCCGTAA с параметром ${k=2}$.}
	\label{fig:debruijn}
\end{figure}

Максимальное количество возможных вершин в графе де Брюйна равно $4^k$, а количество рёбер между ними --- $4^{k+1}$. При небольших значениях $k$ в графе, скорее всего, будут присутствовать почти все варианты вершин, а сам граф будет близок к полносвязному, что даёт плохое представление о геноме. С другой стороны, при больших $k$ граф может распасться на несвязные компоненты. Поэтому, например, ассемблер SPAdes проводит последовательно несколько сборок для разных $k$ и часто останавливается для запутанных геномов и метагеномов на значении 55.

Так как пути в графе де Брюйна образуют контиги, вершины, в которые входит и выходит ровно по одному ребру, можно удалить, объединив соответствующие рёбра в одно, так как с точки зрения обхода графа такие вершины не информативны. Пример такого упрощения можно видеть на рисунке \ref{fig:debruijn_simpl}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.22]{debruijn_simpl.png}
	\caption{Граф сборки, полученный в результате упрощения графа с рисунка \ref{fig:debruijn}.}
	\label{fig:debruijn_simpl}
\end{figure}

Граф, полученный в результате упрощения графа де Брюйна, называется графом сборки. На самом деле, упрощение необходимо по нескольким причинам, которые описаны в работе \cite{art:disser_andrey}. В частности, это позволяет удалить рёбра, в которых содержатся ошибки.

\subsection{Выравнивание последовательностей}
Выравнивание последовательностей --- это процесс сопоставления символов одной строки символам другой так, чтобы максимизировать функцию похожести этих последовательностей. Если мы ожидаем, что последовательности небольшие и должны хорошо совпадать по всей свой длине, то в качестве функции похожести можно взять редакционное расстояние. Если известны какие-то особенности последовательностей, то лучше воспользоваться аффинным выравниванием (например, можно не штрафовать за большие несовпадающие участки). Находить точное значение функции требует количество действий, пропорциональное произведению длин, что для длинных строк неприемлемо, поэтому ограничиваются лишь приближёнными значениями \cite{art:likic2008needleman}.

Особенностью выравнивания ребер графа сборки на последовательность заключается в том, что ребро может соответствовать одновременно нескольким фрагментам последовательности, а также выравниваться лишь частично.

Помимо этого, существует задача выравнивания последовательности на целый граф сборки \cite{art:spaligner, art:rautiainen2020graphaligner}. В ней требуется найти \textit{путь} в графе, строковое представление которого максимально похоже на выравниваемую последовательность. 

\subsection{Инструменты для выравнивания последовательностей }

% \textbf{blat}

% \textbf{bwa}

\textbf{minimap2} \cite{art:minimap2} разрабатывался в ответ на появление технологий секвенирования, которые создают очень длинные риды (100 kbp в среднем). Его главное преимущество --- выравнивание длинных последовательностей ДНК на большие референсные геномы более чем в 30 раз быстрее \cite{art:minimap2} по сравнению с существующими инструментами, при этом сохраняя достаточно высокий уровень точности.

\textbf{winnowmap} \cite{art:winnowmap} основывается на minimap2 и рассматривает проблему неравномерного распределения k-меров в геноме, уменьшая количество ложно-положительных совпадений. Однако впоследствии его идеи были включены в последние версии minimap2.

\textbf{GraphAligner} \cite{art:rautiainen2020graphaligner}, в отличие от предыдущих инструментов, предназначен для выравнивания последовательности на целый граф сборки. Он основывается на идее выравнивания последовательности на граф на основе битового параллелизма \cite{art:bpstga}. Основное преимущество --- выравнивание в 12 раз быстрее и в 2 раза точнее по сравнению с существующими инструментами \cite{art:rautiainen2020graphaligner}. Помимо этого, полезной возможностью является нахождение не одного лучшего выравнивания, а сразу нескольких.

% \textbf{SPAligner} \cite{art:spaligner} основывается 

\subsection{Существующие решения}
\textbf{LoRDEC} \cite{art:salmela2014lordec} стал первым инструментом, который использовал граф де Брюйна, построенный из коротких ридов, в качестве индекса для исправления длинных ридов. В LoRDEC длинные риды привязывались к графу, используя общие k-меры. Затем непривязанные подпоследовательности исправлялись с помощью путей, которые похожи на исправляемые подпоследовательности. Многие инструменты для гибридного исправления ошибок в длинных ридах основываются на этом подходе LoRDEC.

\textbf{Jabba} \cite{art:miclotte2016jabba}, помимо использования подхода LoRDEC, перед построением графа применяет самокоррекцию коротких ридов. Кроме этого, длинные риды привязываются к графу, используя максимально точные совпадения, чтобы использовать k-меры разной длины во время исправления ошибок.

\textbf{HG-CoLoR} \cite{art:morisse2018hybrid} также применяет самокоррекцию коротких ридов, а также выравнивает их на длинные риды, чтобы найти перекрытия между собой. Эти перекрытия привязывают риды к графу де Брюйна переменного порядка с учётом разных длин k-меров.

\textbf{FMLRC} \cite{art:wang2018fmlrc} индексирует граф де Брюйна, используя многострочное преобразование Барроуза — Уилера (англ. multi-string Burrows-Wheeler Transform) коротких ридов. Это представление занимает мало места в памяти, допускает несколько длин k-меров и неявно сохраняет частоту появления k-меров. Исправление ошибок в FMLRC происходит в два прохода: во время первого используется небольшое значение k для k-меров, в то время как для второго используется k больше, чтобы упростить граф в особо сложных местах.

\textbf{CoLoRMap} \cite{art:haghshenas2016colormap}, в отличии от вышеупомянутых инструментов, строит граф взвешенных выравниваний из сопоставления коротких ридов длинным. Это сопоставление позволяет получить пути в графе, которые максимально похожи на подпоследовательности исправляемых последовательностей. CoLoRMap использует информацию о парных концах коротких ридов, чтобы перепрыгнуть регионы длинных ридов, которым не сопоставлен ни один короткий рид.

\textbf{Ratatosk} \cite{art:holley2021ratatosk} в свою очередь, во первых, некоторым образом раскрашивает вершины графа де Брюйна с помощью коротких и длинных ридов, чтобы выделить существующие пути для исправления. Раскраска графа позволяет уменьшить пространство обхода графа, удаляя химерные пути\footnote{пути, образованные последовательностями разных организмов}.
Во вторых, длинные риды привязываются к графу, используя как точное совпадение k-меров, так и неточное, что позволяет привязать регионы с большим количеством ошибок. В третьих, граф аннотируется кандидатами на точечные ошибки в один нуклеотид, что позволяет выделить небольшие вариации между похожими участками генома, которые трудно уловить из ошибочных длинных ридов. В четвёртых, коррекция выполняется в два прохода, используя короткие и длинные риды по отдельности.

Для получения большей информации об исправлении ошибок в длинных ридах можно воспользоваться обзорами \cite{art:morisse2020long, art:zook2016extensive, art:zhang2020comprehensive}.

\subsection{Оценка качества сборки}
Для того чтобы понять, насколько результат сборки соответствует реальному геному, существует много метрик. Одни можно вычислить только по результату сборки, другие же требуют наличие референсного генома --- некоторого эталонного генома для данного вида организма. Метрики, использующие референсный геном, позволяют намного детальнее оценить качество сборки. Стоит отметить, что собранный геном не должен полностью совпадать с референсным геномом, так как геном исследуемого организма может отличаться от эталонного на 1-2\%.

Одной из программ, позволяющих вычислять оба вида метрик, является QUAST \cite{art:QUAST}. Помимо одиночных геномов он также поддерживает использование  метагеномов для оценки качества сборки как отдельных геномов в него входящих, так и их объединения \cite{art:metaquast}.

%==============================================================================
\section{Алгоритм}

Представленный в данной работе алгоритм является эвристическим. Все приведённые точные значения являются параметрами алгоритма по умолчанию и были получены как близкие к оптимальным при тестировании на различных данных.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[
    every node/.style={
      draw=black,
      anchor=west,
      minimum height=1cm,
      rounded corners 
      }, 
    font=\small
    ]
    \begin{scope}[on grid]
    \node[ellipse, inner sep=0pt] (graph)               {граф сборки};
    \node (align) [left = 2cm of graph.west] {1. выравнивание рёбер графа на последовательности};
    \node[draw=purple] (filter) [below  right = 2cm and 7cm of align] {2. фильтрация выравниваний};
    \node[draw=purple, align=left] (filling) [below = 2cm of filter] {3. нахождение и смешивание путей \\ между выравниваниями};
    \node[draw=purple] (write back) [left = 1cm of filling.west] {4. перенос путей в последовательности};
    \node[ellipse, inner sep=0pt] (seq)  [above = 2cm of write back] {зашумлённые последовательности};
    \end{scope}

    \path[->]
    (align) edge (filter)
    (filter) edge (filling)
    (filling) edge (write back)
    ;
    \path[->, dashed]
    (graph) edge (align) edge [bend left=54] (filling)
    (seq) edge (align) edge (filling) edge (write back)
    ;
\end{tikzpicture}
\caption{Алгоритм коррекции. Фиолетовым цветом обозначены стадии, описанные в данной работе. Пунктирными стрелками --- использование данных.}
\label{fig:pipeline}
\end{figure}

Перед началом работы алгоритма коррекции считается, что уже имеются какие-то зашумлённые последовательности, а также уже построен граф сборки с помощью какого-либо ассемблера. Эти последовательности и граф являются входными данными. В конце работы алгоритм выдаёт те же самые последовательности, но с исправленными ошибками. 

Алгоритм коррекции состоит из следующей последовательности шагов, изображённых на рисунке \ref{fig:pipeline}.
\begin{enumerate}
    \item Для выравнивания рёбер графа сборки на исправляемые последовательности может быть использован любой из существующих методов. Так как в графе уже присутствуют как прямые рёбра, так и обратно-комплементарные, необходимо получить выравнивания рёбер только в их прямом направлении. Кроме того, так как в графе есть неуникальные рёбра (например, отражают повтор в геноме или принадлежат нескольким организмам в метагеноме), необходимо получить все выравнивания ребра, которые нашёл выравниватель, а не только одно наилучшее.
    \item Найденных выравниваний довольно много, они перекрывают друг друга, и далеко не все из них действительно должны находиться на найденных местах (например, повторы). Поэтому их нужно отфильтровать. Те выравнивания рёбер, что останутся, будем называть \textit{якорями}.
    \item \begin{sloppypar} Помимо исправления последовательностей непосредственно якорями, нужно исправлять и другие места. Для этого между якорями находятся пути, которые затем смешиваются для получения строки, которая заменит фрагмент последовательности между этими якорями. Будем называть такие строки \textit{строками-заменителями}. Якоря со строками-заменителями между ними образуют \textit{смешанный путь} в графе. \end{sloppypar}
    \item Полученные смешанные пути переносятся в исправляемые последовательности.
\end{enumerate}

\subsection{Фильтрация выравниваний}
Из множества всех найденных выравниваний на рёбра графа нас интересуют те, которые <<скорее всего>> находятся на правильном месте. Так, например, с увеличением длины ребра, вероятность, что оно будет выравнено на множество мест, уменьшается.

Для выбора якорей используются два фильтра: грубый (англ. rough) и точный (англ. fine). Грубый фильтр работает на этапе чтения выравниваний и оценивает их правильность в отрыве от остальных выравниваний посредством следующих критериев:
\begin{itemize}
    \item длина выравнивания (а значит и длина ребра) больше минимальной разрешённой длины (minAlignmentLength, по умолчанию $300$ символов);
    \item выравненные фрагмент последовательности и фрагмент ребра совпадают как минимум на minAlignmentIdentity (по умолчанию $50\%$), то есть их идентичность\footnote{Отношение удвоенного количества совпавших символов к сумме длин сопоставленных подстрок.} (англ. identity) $> $minAlignmentIdentity$\%$;
    \item разница длин выравненных фрагмента последовательности и фрагмента ребра не превышает ожидаемого уровня ошибочности сборки (expectedErrorness, по умолчанию $5\%$ для контигов);
    \item выравнивание является одним из случаев:
    \begin{itemize}
        \item ребро полностью содержится в последовательности;
        \item последовательность полностью содержится в ребре;
        \item конец ребра является началом последовательности;
        \item начало ребра является концом последовательности\footnote{Часто <<конец/начало ребра/последовательности>> не является суффиксом/префиксом из-за наличия ошибок, поэтому необходимо допускать небольшой отступ, например, не больше $k$ символов.};
        \item выравнялась лишь часть ребра, но она достаточно длинная ($\ge$ longAlignmentLength, по умолчанию 2000 символов), чтобы можно было считать это структурным отличием графа от последовательности;
    \end{itemize}
\end{itemize}

Точный фильтр оценивает правильность выравнивания на основе уникальности. Выравнивание считается \textit{уникальным}, если его ребро имеет не больше одного выравнивания, которое полностью содержится в какой-либо последовательности. Выравнивание принимается точным фильтром, если оно:
\begin{itemize}
    \item не короткое ($\ge$shortAlignmentLength, по умолчанию 700) и уникальное;
    \item короткое (<shortAlignmentLength), уникальное и идентичность выше uniqueShortAlignmentIdentity (по умолчанию $70\%$).
    \item неуникально и идентичность выше nonuniqueAlignmentIdentity (по умолчанию $90\%$).
\end{itemize}

Оставшиеся после фильтрации выравнивания рёбер будем называть \textit{якорями}. 

Для каждого якоря определяется уровень достоверности:
\begin{enumerate}
    \item высокий: якорь уникальный;
    \item \begin{sloppypar}средний: якорь неуникальный и средней длины ($\ge$middleAlignmentLength, по умолчанию 1000 символов);\end{sloppypar}
    \item низкий: оставшиеся якоря;
\end{enumerate}

После фильтрации якоря потенциально всё ещё могут быть взаимоисключающими (то есть пересекаться больше, чем на $k+\varepsilon$, где $k$ --- количество символов пересечения смежных рёбер в графе, а $\varepsilon$ --- несколько символов для возможных ошибок, например, $5$). Взаимоисключающие рёбра отбрасываются следующим образом:
\begin{itemize}
    \item для каждой пары якорей проверяется, конфликтуют ли они. Если да, то:
    \begin{itemize}
        \item если у них разные уровни достоверности, то на удаление помечается тот, что с меньшим;
        \item если уровни достоверности одинаковые и длины якорей отличаются больше, чем в два раза, то помечается тот, что с меньшей;
        \item иначе помечаются оба;
    \end{itemize}
    \item все помеченные якоря разом отбрасываются;
\end{itemize}

Тем не менее, критериев фильтрации на практике оказывается достаточно, чтобы взаимоисключающих рёбер было не больше всего нескольких единиц из класса с низким уровнем достоверности.

\subsection{Пути между якорями}
Расположим якоря в порядке встречи их в последовательности. Заполнение пространства вне якорей проходит следующим образом.
\begin{itemize}
    \item Для каждой пары смежных якорей самого достоверного класса находятся пути в графе, которые отличаются не больше, чем на $2*$expectedErrorness$\%$ от длины фрагмента последовательности между этими якорями. Найденные пути затем и смешиваются и формируют строки-заменители.
    \item Если между двумя якорями не было сформировано строки-заменителя, то в этот промежуток добавляются якоря из следующего класса достоверности и процесс поиска-смешивания-формирования повторяется.
\end{itemize}

Между якорями ищутся все пути, чтобы на этапе смешивания быть уверенным, что различия между похожими участками генома не будут потеряны. Так как графы устроены довольно сложно, путей даже между не очень удалёнными якорями (несколько тысяч символов) может быть чрезвычайно много (десятки и сотни тысяч), то поиск имеет несколько ограничений, выход за которые, как показывает наша практика, не имеет смысла. Сам поиск проходит в два этапа.
\begin{enumerate}
    \item С помощью алгоритма Дейкстры в графе помечаются все вершины, через которые существует путь с заданным ограничением сверху на длину. Количество найденных вершин не должно превышать maxDijkstraVertices (по умолчанию 3000).
    \item \begin{sloppypar}Поиском в глубину по помеченным вершинам выбираются все пути с заданными ограничениями на длину. При этом суммарное количество рекурсивных вызовов не должно превышать maxCallCnt (по умолчанию 3000), а если оно превысило vertexUsageEnableThreshold (по умолчанию 500), то дополнительно проверяется, чтобы в найденном пути было не больше maxVertexUsage (по умолчанию 5) одинаковых рёбер.\end{sloppypar}
\end{enumerate}
Если поиск обнаружил превышение данных ограничений, процесс получения строки-заполнителя между текущей парой якорей прерывается. Эти ограничения выбраны таким образом, чтобы большинство случаев поиска завершалось с большим запасом до их превышения, но на слишком запутанных частях графа они быстро прерывались.

\subsection{Смешивание путей}
После того, как все пути между якорями найдены, необходимо понять, что из этого может исправить последовательность, а что испортить. 
Для этого каждый путь выравнивается на фрагмент последовательности. Если расстояние между ними слишком велико, то этот путь отбрасывается. Часть с выравниванием является самой трудоёмкой частью всего пайплайна коррекции и занимает больше $95\%$ времени, поэтому происходит параллельно.

Оставшиеся пути упорядочиваются в порядке возрастания расстояния. Если остался всего один путь, или у первого пути расстояние существенно\footnote{Довольно часто лучшие пути имеют расстояние 0-5, что является несущественным отличием, чтобы однозначно сказать, что какой-то путь лучше. Поэтому, помимо процентного соотношения (в два раза), стоит использовать и абсолютный порог (на десять).} меньше, чем у второго, то этот путь становится \textit{кандидатом} на строку-заменитель.

Не каждый кандидат становится строкой-заменителем. Чтобы это произошло, он должен отличаться от фрагмента последовательности не больше, чем среднее количество ошибок в текущей последовательности (это значение вычисляется после выбора якорей на основании их среднего значения идентичности).

Довольно часто все найденные пути являются порождением подграфа, который представляет из себя набор <<пузырей>> (альтернатив из двух подпутей), например, как на рисунке \ref{fig:buldges}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{buldges.png}
    \caption{Подграф, содержащий два <<пузыря>>: (x, x') и (y, uv).}
    \label{fig:buldges}
\end{figure}

Пузыри зачастую образуются в результате наличия повторов в геноме, или когда есть похожие фрагменты у двух организмов (например, двух штаммах бактерии) в метагеноме. Рёбра в них отличаются весьма слабо, поэтому, если разложить такой подграф на два пути (с рисунка \ref{fig:buldges} это $axbyc$ и $ax'buvc$), можно выравнять эти пути между собой, найти места, которые в них отличаются, и заменить их на фрагменты из исправляемой последовательности. Таким образом вариации между похожими участками генома будут сохранены, а ошибки исправлены. Полученная строка является также лишь кандидатом на строку-заменитель, чтобы избежать случайного внесения большого количества ошибок в последовательность.

Попытка сжатия путей до двух происходит следующим образом.  Сначала строится вспомогательный ориентированный граф. Для этого каждое ребро каждого пути представляется парой: id ребра и порядковый номер его вхождения в этот путь. Эти пары становятся вершинами в новом графе. Если два ребра стоят подряд в пути, то в новом графе между соответствующими им парами будет ребро. Пример на рисунке \ref{fig:compresed_paths}.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[every node/.style={circle,draw=black}]
    \begin{scope}[on grid]
    \node (a0)               {$a,0$};
    \node (x)  [below right=1cm and 2.25cm of a0] {$x,0$};
    \node (y)  [right=2.5cm of x ] {$y,0$};
    \node (b)  [above right=1cm and 3.5cm of a0] {$b,0$};
    \node (a1) [above right=1cm and 2.25cm of y]  {$a,1$};
    \node (g0) [above right=1cm and 2.25cm of a1] {$g,0$};
    \node (g1) [right=2.5cm of g0] {$g,1$};
    \node (c)  [below right=1cm and 3.5cm of a1] {$c,0$};
    \node (d)  [below right=1cm and 2.25cm of g1] {$d,0$};
    \end{scope}

    \path[->]
    (a0) edge (b) edge (x)
    (b) edge (a1)
    (x) edge (y)
    (y) edge (a1)
    (a1) edge (g0) edge (c)
    (g0) edge (g1)
    (g1) edge (d)
    (c) edge (d)
    ;
\end{tikzpicture}
\caption{Пример сжатия четырёх путей (каждая буква является ребром пути): $abacd$, $abaggd$, $axyacd$, $axyaggd$. Первый путь даёт вершины $(a,0)$, $(b,0)$, $(a,1)$, $(c,0)$, $(d,0)$ и соединения между ними. Для остальных путей аналогично.}
\label{fig:compresed_paths}
\end{figure}

В процессе и после построения вспомогательного графа проверяется его корректность: 
\begin{itemize}
    \item нет циклов и петель;
    \item начальные и конечные вершины совпадают с начальными и конечными вершинами каждого из путей;
    \item у каждой общей вершины не больше двух входящих и двух исходящих рёбер;
    \item у каждой вершины из альтернатив ровно по одному входящему и исходящему ребру;
\end{itemize}

Если граф получился корректным, то получаем два пути: первый состоит из общих вершин и первых альтернатив, а второй --- из общих вершин и вторых альтернатив. Если же корректность нарушена, то сжать пути не удалось и между текущими двумя якорями последовательность исправлена не будет.

Несмотря на то, что есть примеры, когда пути сжать можно, но он этого не делает (например, $aaa$ и $aba$), на практике этого алгоритма достаточно, чтобы сжать почти все подходящие наборы путей.

\subsection{Перенос путей в последовательность}
После того, как будут получены строки-заменители, их необходимо разместить обратно в исправляемую последовательность. Для определения фрагмента последовательности, соответствующего данной строке, используются выравнивания с первого шага алгоритма --- это диапазон с позиции первого символа первого якоря в составе строки до позиции последнего символа в последнем якоре в составе строки. Стоит отметить, что диапазоны строк-заменителей могут пересекаться вплоть до $k+\varepsilon$, при этом символы в перекрытии могут не совпадать. Чтобы избежать внесения ошибок, эти конфликты решаются следующим образом. Обозначим за $a$ и $b$ фрагменты перекрытия, соответствующие первой и второй строкам-заменителям, а за $s$ соответствующий фрагмент последовательности. Тогда:
\begin{enumerate}
    \item если $a=b$, то выбирается $a$;
    \item если $a=s$ или $b=s$, то выбирается $s$;
    \item в противном случае также выбирается $s$;
\end{enumerate}
Для третьего случая можно воспользоваться смешиванием из предыдущего шага, тем самым исправляя общие символы и не меняя несовпадающие, но на практике таких случаев обычно всего несколько штук на сборку, поэтому если ошибки и останутся неисправленным, то в пренебрежимо малом количестве.

%==============================================================================
\section{Архитектура решения}
В данной главе приведена архитектура приложения, которое выполняет непосредственно коррекцию. Все рисунки представлены в виде диаграмм активностей.

\begin{figure}[h]
    \centering
    \includegraphics{NIR_arch-Page-4.png}
    \caption{Диаграмма общей структуры алгоритма}
    \label{fig:arch:top_lvl}
\end{figure}

Работа приложения, как показано на рисунке \ref{fig:arch:top_lvl}, начинается с чтения выравниваний, которые сразу же проходят грубый фильтр, который отфильтровывает б\'{о}льшую их часть. Затем определяется, является ли выравнивание уникальным, и применяется точный фильтр. После этого для каждой последовательности независимо находятся пути между её якорями, которые далее заменяют соответствующие им фрагменты. В конце полученные исправленные последовательности сохраняются. При необходимости также сохраняется информация о том, какие фрагменты были исправлены, тип исправления (смешанный путь, чистый путь, перекрытие соседних рёбер, или же само ребро), а также дополнительная информация об исправлении (например, идентичность старого и нового фрагментов). 

\begin{figure}[h]
    \centering
    \includegraphics{NIR_arch-Page-2.png}
    \caption{Диаграмма покрытия последовательности путями}
    \label{fig:arch:cover}
\end{figure}

Процесс получения путей между якорями, входом в который является узел <<покрыть путями>>, изображён на рисунке \ref{fig:arch:cover}. Якоря сортируются в порядке вхождения в последовательность, а затем совершается проход по ним, где для каждого текущего якоря сначала находится его правый сосед с таким же или выше уровнем достоверности. Между этими двумя якорями ищутся все пути в графе, которые затем смешиваются. В случае успеха следующим якорем выбирается правый из текущей пары, тем самым пропускаются якоря меньшего уровня достоверности. Если же какой-то этап завершился неудачей, то для текущего якоря понижается уровень достоверности и поиск происходит заново. Если происходит попытка понизить уже минимальный уровень, то текущий якорь становится последним в текущем пути, а алгоритм переходит к рассмотрению следующего подряд якоря. После того, как был рассмотрен последний якорь, происходит возврат найденных путей через узел <<покрыто путями>>.

\begin{figure}[h]
    \centering
    \includegraphics{NIR_arch-Page-3.png}
    \caption{Диаграмма смешивания путей}
    \label{fig:arch:mix}
\end{figure}

Процесс смешивания путей, входом в который является узел <<смешать пути>>, изображён на рисунке \ref{fig:arch:mix}. Сначала для каждого пути параллельно находится его выравнивание на соответствующий фрагмент последовательности. Если расстояние до него оказывается слишком велико, то путь отбрасывается. Затем, если остался единственный путь, или есть путь, который по расстоянию значительно лучше остальных, то он становится кандитатом на замену. Если же путей много, то происходит попытка их сжать в два пути, а затем смешать с фрагментом последовательности. Результат этого смешения также становится кандидатом на замену. Если кандидат успешно найден, то проверяется, что его расстояние до фрагмента последовательности не превосходит среднее количество ошибок во всей последовательности, а затем происходит возврат через узел <<смешать удалось>>. Если же сжать пути не удалось или же кандидат на замену слишком отличается от последовательности, то в качестве заменителя фрагмента ничего не выбирается и происходит возврат через узел <<смешать не удалось>>.

%==============================================================================
\section{Наивный алгоритм}
Можно заметить, что решение довольно похоже на решение задачи выравнивания последовательностей на граф (т.е. нахождение как можно более длинных путей в графе, которые соответствуют фрагментам последовательностей). Кажется, что отличие лишь в том, что мы дополнительно по-умному смешиваем пути между якорями на уровне нуклеотидов. Поэтому необходимо провести сравнение со следующим алгоритмом:
\begin{enumerate}
    \item взять существующий выравниватель на граф;
    \item взять несколько лучших выравниваний для каждого фрагмента последовательности;
    \item смешать найденные пути;
\end{enumerate}

\subsection{Кластеризация}
\begin{sloppypar}
Для проверки данного алгоритма был взят выравниватель GraphAligner. Он уже выдаёт несколько лучших найденных выравниваний для каждой области последовательности. Так как пути покрывают похожие, но не идентичные фрагменты, нужно разбить пути на кластера, которые будут покрывать как можно больше длины последовательности, и как можно меньше пересекаться (т.е. конфликтовать) друг с другом. Для этого будем последовательно объединять пути в кластера по следующему критерию: если два пути перекрываются выравниваниями больше, чем на $70\%$, то они лежат в одном кластере. Как показывает практика, на наших тестах этого критерия было достаточно, чтобы лучшие по идентичности пути в кластерах покрывали последовательность на $95-100\%$, все пути в кластере попарно пересекались минимум на $70\%$, а пути различных кластеров практически не пересекались ($<1\%$).
\end{sloppypar}

\subsection{Смешивание}
Пути в полученных кластерах смешиваются следующим образом.
\begin{enumerate}
    \item Выбирается лучший путь в кластере по идентичности с последовательностью.
    \item Все остальные пути выравниваются на лучший.
    \item По полученным выравниваниям помечаем символы и позиции между символами лучшего пути помечаются недостоверными, если хотя бы в одном выравнивании есть отличие.
    \item Недостоверные места заменяются символами из последовательности.
\end{enumerate}

Полученные после смешения строки переносятся обратно способом, описанным в разделе <<Перенос путей в последовательность>>.

%==============================================================================

\section{Апробация}
В данной главе будет приведён сравнительный анализ реализации описанного в даной работе алгоритма на симулированных и синтетических метагеномных сообществах как с существующими решениями, так и с наивным алгоритмом.

\subsection{Метрики}
Сравнение качества коррекции начинается с выравнивания исправленных последовательностей на референсный геном. После этого для общих фрагментов используются следующие метрики:
\begin{itemize}
    \item \textit{количество замен} --- количество \textbf{символов} в выравнивании, в которых нуклеотиды последовательности не совпадают с сопоставленными им нуклеотидами референсного генома. Пример на рисунке \ref{fig:alignment};
    \item \textit{количество вставок и удалений} --- количество \textbf{непрерывных участков} в выравнивании, которые присутствуют либо только в последовательностях, либо только в выравненной части референсного генома. Пример на рисунке \ref{fig:alignment};
    \item \textit{количество замен на 100 kbp} --- среднее количество замен на 100 kbp;
    \item \textit{количество вставок и удалений на 100 kbp} --- среднее количество вставок и удалений на 100 kbp;
    \item \textit{покрытие генома} --- процент нуклеотидов референсного генома, которые покрыты контигами;
    \item \textit{количество структурных ошибок} --- количество релокаций, инверсий, транслокаций. Пример изображён на рисунке \ref{fig:miss};
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{misassemblies.png}
    \caption{Дан контиг, состоящий из двух частей, расположение которых при сопоставлении с референсным геномом определяет тип структурной ошибки.}
    \label{fig:miss}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{alignment.eps}
    \caption{Пример выравнивания строк AAAAAAGTGGTTGATGGTT и GTGTTCCTGATACTTTTTT. Серым цветом выделены невыравненные фрагменты. Зелёным --- совпавшие фрагменты. Красным --- замены. Жёлтым --- вставки и удаления. Таким образом, в данном выравнивания есть две <<замены>> и две <<вставки и удаления>>.}
    \label{fig:alignment}
\end{figure}

\subsection{Схема сравнения}
На рисунке \ref{fig:common_pipeline} показана общая схема проведения сборки раздельно из длинных и коротких ридов.

\begin{figure}[h]
    \centering
\begin{tikzpicture}[
    every node/.style={
      draw=black,
      anchor=west,
      minimum height=1cm,
      align=center,
      rounded corners 
      }, 
    font=\small
    ]
    \begin{scope}[on grid]

        \node (cor1) {коррекция длинных\\ридов};
        \node (assembly) [right = 1cm of cor1.east] {сборка из длинных\\ридов};
        \node (cor2) [right = 1cm of assembly.east] {коррекция контигов сборки\\из длинных ридов};
        \node[ellipse, inner sep=0pt] (long reads) [above = 2cm of cor1] {длинные риды};
        \node[ellipse, inner sep=0pt] (graph) [above right = 2cm and 2cm of assembly] {граф сборки из коротких ридов};

    \end{scope}

    \path[->]
    (cor1) edge (assembly)
    (assembly) edge (cor2)
    ;
    \path[->, dashed]
    (long reads) edge (cor1)
    (graph) edge (cor1) edge (cor2)
    ;
\end{tikzpicture}
\caption{Процесс раздельной сборки из коротких и длинных ридов начинается с получения графа сборки. Затем, опционально, длинные риды можно подвергнуть коррекции, после чего из них происходит непосредственно сборка генома, контиги которой также можно опционально попытаться исправить.}
\label{fig:common_pipeline}
\end{figure}

В ходе апробации используются следующие три варианта сравнения:
\begin{itemize}
    \item применяется коррекция только длинных ридов;
    \item применяется коррекция только контигов;
    \item применяется коррекция как длинных ридов, так и контигов;
\end{itemize}

Среди инструментов, которые исправляют длинные риды при помощи коротких ридов, последним вышедшим (2021 г.) и одним из лучших является Ratatosk \cite{art:holley2021ratatosk, art:zhang2020comprehensive, art:fu2019comparative}, поэтому сравнительный анализ будет приведён именно с ним.

Стоит отметить, что реализованный в данной работе алгоритм применяется только для коррекции контигов сборки, так как каждый фрагмент генома в среднем покрывается лишь одним контигом, что неверно для ридов. Из-за этого описанная в разделе <<выбор якорей>> оценка уникальности выравниваний будет работать некорректно.

Во всех тестах граф сборки из коротких ридов получен ассемблером SPAdes. Для сборки из длинных ридов использовался ассемблер Flye \cite{art:flye}. Инструментом для сбора метрик и сравнения является Quast.

Во всех следующих разделах, кроме <<Сравнение с наивным алгоритмом>> в таблицах приведены следующие варианты сборки контигов с соответствующими названиями столбцов:
\begin{enumerate}
    \item $[$\textbf{raw flye}$]$ ни одна коррекция не применяется;
    \item $[$\textbf{ratatosk contigs}$]$ ratatosk исправляет только контиги;
    \item $[$\textbf{ratatosk reads}$]$ ratatosk исправляет только длинные риды;
    \item $[$\textbf{our contigs}$]$ мы исправляем только контиги;
    \item $[$\textbf{ratatosk and we}$]$ ratatosk исправляет длинные риды, а мы --- контиги;
    \item $[$\textbf{ratatosk ratatosk}$]$ ratatosk исправляет как длинные риды, так и контиги.
\end{enumerate}

В таблицах также используется тепловая карта: красным цветом отображён худший результат, синим --- лучший, белым --- медиана. 

\subsection{Сравнение с наивным алгоритмом}
В данном разделе приводится сравнение двух алгоритмов, представленных в работе. Тестирование проводилось на метагеноме Zymo.

Столбцы на рисунках \ref{fig:general_mix}, \ref{fig:mismatches_mix} и \ref{fig:indels_mix}:
\begin{enumerate}
    \item $[$\textbf{flye}$]$ контиги Flye без коррекции;
    \item $[$\textbf{we}$]$ контиги после коррекции основным алгоритмом;
    \item $[$\textbf{mixed}$]$ контиги после коррекции наивным алгоритмом;
    \item $[$\textbf{best}$]$ контиги после коррекции наивным алгоритмом с той лишь разницей, что после выбора лучшего пути смешения с остальными не происходит;
\end{enumerate}

\begin{figure}[h!]
    \centering
    \include{tables/mix.general.tex}
    \caption{Суммарная статистика по всем геномам Zymo для основного и наивного алгоритма}
    \label{fig:general_mix}
\end{figure}

\begin{figure}[h!]
    \centering
    \include{tables/mix.mismatches.tex}
    \caption{Замены в метагеноме Zymo для основного и наивного алгоритма}
    \label{fig:mismatches_mix}
\end{figure}

\begin{figure}[h!]
    \centering
    \include{tables/mix.indels.tex}
    \caption{Вставки и удаления в метагеноме Zymo для основного и наивного алгоритма}
    \label{fig:indels_mix}
\end{figure}

Из таблицы \ref{fig:indels_mix} видно, что по вставкам и удалениям наивный алгоритм в паре мест немного обходит основной.

Однако из таблицы \ref{fig:mismatches_mix} видно, что по количеству замен наивный алгоритм не только проигрывает основному, но и в половине случаев вносит ошибок больше, чем исправляет. Особое внимание стоит обратить на бактерию Salmonella Enterica, для неё пути GraphAligner прошлись по похожим рёбрам другой бактерии, что привело к всплеску замен.


\subsection{Симулированные метагеномы}
В текущем разделе описан результат сравнения на симулированном метагеноме из 20 организмов.

\begin{figure}[h!]
    \include{tables/base20.general.tex}
    \caption{Суммарная статистика по всем геномам симуляции}
    \label{fig:general_base20}
\end{figure}

\begin{figure}[h!]
    \include{tables/base20.mismatches.tex}
    \caption{Замены в симулированном метагеноме}
    \label{fig:mismatches_base20}
\end{figure}

\begin{figure}[h!]
    \include{tables/base20.indels.tex}
    \caption{Вставки и удаления в симулированном метагеноме}
    \label{fig:indels_base20}
\end{figure}

Из таблицы \ref{fig:general_base20} видно, что покрытие генома практически не изменилось, а значит во всех случаях была произведена именно коррекция. Тем не менее, при исправлении длинных ридов Ratatosk внёс ошибки, которые привели к увеличению количества структурных ошибок при сборке контигов. Последующая коррекция контигов с использованием Ratatosk усугубило проблему, в то время как описанный в данной работе алгоритм смог исправить более $60\%$ внесённых структурных ошибок.

Представленный алгоритм в одиночку смог сократить количество замен в 3 раза, а количество вставок и удалений --- в 4 раза. По сравнению с коррекцией контигов с использованием Ratatosk, это на $15\%$ хуже для замен, но на $10\%$ лучше для вставок и удалений.

Комбинирование коррекций здесь является безусловным фаворитом, которое снизило количество замен в 5.5 раз, а количество вставок и удалений --- почти в 8 раз, что примерно в два раза лучше, чем аналогичный сценарий с использованием только Ratatosk.

\subsection{Синтетические метагеномные сообщества}
Синтетическое метагеномное сообщество --- это сообщество, организмы которого были отдельно друг от друга выращены и просеквенированы для получения точного референсного генома. Однако для получения ридов метагенома секвенируется смесь из них. В данном разделе будут представлены результаты для двух синтетических метагеномных сообществ: Bmock12 и Zymo.

\subsubsection*{Bmock12}
Bmock12 --- это синтетическое сообщество, состоящее из смеси одиннадцати бактериальных организмов. 

\begin{figure}[h!]
    \include{tables/bmock12.general.tex}
    \caption{Суммарная статистика по всем геномам в Bmock12}
    \label{fig:general_bmock12}
\end{figure}

\begin{figure}[h!]
    \include{tables/bmock12.mismatches.tex}
    \caption{Замены в метагеноме Bmock12}
    \label{fig:mismatches_bmock12}
\end{figure}

\begin{figure}[h!]
    \include{tables/bmock12.indels.tex}
    \caption{Вставки и удаления в метагеноме Bmock12}
    \label{fig:indels_bmock12}
\end{figure}

Из таблицы \ref{fig:general_bmock12} видно, что покрытие генома изменилось незначительно, а значит во всех случаях была произведена именно коррекция. Однако при исправлении длинных ридов Ratatosk внёс ошибки, которые привели к увеличению количества структурных ошибок при сборке контигов. Последующая коррекция контигов с использованием Ratatosk усугубило проблему, в то время как описанный в данной работе алгоритм смог исправить более $60\%$ внесённых структурных ошибок.

\subsubsection*{Zymo}
ZymoEven --- это синтетическое сообщество, состоящее из смеси  девяти бактериальных и дрожжевых организмов. Концентрация как длинных, так и коротких ридов равномерно распределена по всем геномам.

\begin{figure}[h!]
    \include{tables/zymo.general.tex}
    \caption{Суммарная статистика по всем геномам в Zymo}
    \label{fig:general_zymo}
\end{figure}

\begin{figure}[h!]
    \include{tables/zymo.mismatches.tex}
    \caption{Замены в метагеноме Zymo}
    \label{fig:mismatches_zymo}
\end{figure}

\begin{figure}[h!]
    \include{tables/zymo.indels.tex}
    \caption{Вставки и удаления в метагеноме Zymo}
    \label{fig:indels_zymo}
\end{figure}

Из рисунка \ref{fig:general_zymo} видно, что покрытие генома и количество структурных ошибок поменялось несущественно, а значит была произведена именно коррекция. Помимо этого, описанный в данной работе алгоритм при коррекции контигов уменьшает количество замен примерно в 3 раза, а количество вставок и удалений --- в 10 раз. По количеству замен это на $20\%$ лучше, чем коррекция длинных ридов Ratatosk, и лишь на $4\%$ хуже по вставкам и удалениям.

Комбинирование коррекций является лучшим результатом, при котором удалось количество вставок и удалений уменьшить в 12 раз, что превосходит аналогичные усилия одного лишь Ratatosk на $16\%$.

%==============================================================================
%% У заключения нет номера главы
% \newpage
% \[\]
\newpage
\section*{Заключение}
В ходе данной работы были получены следующие результаты.
\begin{itemize}
    \item Сформированы критерии фильтрации выравниваний рёбер графа на последовательности.
    \item Разработан алгоритм исправления ошибок за пределами выравненных рёбер с помощью путей в графе.
    \item Разработан алгоритм переноса полученных путей в графе обратно в последовательности.
    \item Итоговый алгоритм реализован в виде отдельного инструмента.
    \begin{itemize}
        \item Реализация выполнена на языке C++ и является подпроектом для ассемблера SPAdes.
        \item \begin{sloppypar} Исходный код SPAdes доступен по ссылке: \mbox{\url{https://github.com/ablab/spades/}}. Реализованный инструмент будет доступен начиная с версии 3.17. \end{sloppypar}
    \end{itemize}
    \item Проведена апробация алгоритма на симулированных и реальных данных.
    \begin{itemize}
        \item Исправление метагеномных сборок низкого качества даёт сравнимый и лучший результат по сравнению с коррекцией ридов и сборок существующими решениями.
        \item Кооперация с существующими решениями даёт существенно лучший результат.
    \end{itemize}

\end{itemize}

%==============================================================================

\section*{Глоссарий}

\textbf{Ассемблер} --- программное обеспечение для получение контигов и скаффолдов из ридов.\\

\textbf{Граф де Брюйна} --- граф с параметром k, который строится по следующим принципам: берётся набор входных строк и выделяется из них множество всевозможных подстрок длины k+1. Тогда k+1-мер --- это ребро, ведущее из своего префикса длины k в суффикс длины k.\\

\textbf{Граф сборки} --- в этой работе: граф, полученный в результате упрощения графа де Брюйна.\\

\textbf{К-мер} --- последовательность длины К.\\

%\textbf{Плазмиды} --- небольшие молекулы ДНК, физически отделённые от хромосом.\\

\textbf{Референсный геном} --- эталонный геном данного вида организма.\\

\textbf{Риды} --- множество фрагментов ДНК, которые получаются в результате секвенирования.\\

\textbf{Контиги} --- восстановленные части ДНК из ридов.\\

\textbf{Скаффолд} --- объединение нескольких контигов с известным расстоянием между ними, но неизвестными самими нуклеотидами.\\

%==============================================================================

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma}
\end{document}
