% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Программная инженерия\\Системное программирование},
    title              = {Исправление ошибок в зашумленных последовательностях при помощи графов сборки},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студента},
    group              = 444,
    author             = {Клещин Антон Сергеевич},
    supervisorPosition = {доц. каф. СП, к.т.н.},
    supervisor         = {Литвинов Ю.\,В.},
    supervisorPositionx   = {доц. каф. СМ, к.ф.-м.н.},
    supervisorx           = {Коробейников А.\,И.},
    supervisorPositiony   = {Научный сотрудник Центра алгоритмической биотехнологии СПбГУ},
    supervisory           = {Пржибельский А.\,Д.},
    reviewerPosition  = {},
    reviewer          = {},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
%\filltitle{en}{
%    chair              = {Software and Administration of Information Systems \\ Software Engineering},
%    title              = {Development of scaffolding algorithms using additional genomic information},
%    type               = {bachelor},
%    author             = {Anton Kleshchin},
%    supervisorPosition = {C.Sc., Associate Professor},
%    supervisor         = {Yurii Litvinov},
%    supervisorPositionx   = {Ph.D., Associate Professor},
%    supervisorx           = {Anton Korobeynikov},
%    supervisorPositiony   = {Research Fellow at the Center for Algorithmic Biotechnology SPbU},
%    supervisory           = {Andrey Prjibelski},
%    reviewerPosition  = {PhD Candidate},
%    reviewer          = {Dmitrii Meleshko},
%}
\maketitle
\tableofcontents
\setcounter{secnumdepth}{4}
%==============================================================================
% У введения нет номера главы
\section*{Введение}
Сборка геномов является одной из важнейших задач биоинформатики. За многие годы учёным уже удалось собрать, а затем и расшифровать большое количество геномов. Несмотря на это, автоматическая реконструкция генома всё ещё остаётся сложной вычислительной задачей \cite{sohn2018present, art:collins2018challenge}.

Обычно сборка генома происходит из ридов (англ. reads) --- фрагментов ДНК, которые получаются в результате секвенирования, а результатом являются контиги (англ. contigs, восстановленные части ДНК из ридов) или скаффолды (англ. scaffolds, восстановленные части ДНК с пропусками известной длины).

Технологии секвенирования не стоят на месте: появилось третье поколение, позволяющие получать длинные риды дешевле, но количество ошибок в них на порядок выше \cite{art:reads}. Несмотря на то, что есть способы частично бороться с этими ошибками \cite{art:alic2016objective}, для улучшения результатов сборки можно прибегнуть к другим методам. Например, для небольших геномов активно применяется метод гибридной сборки \cite{art:hybridSpades}, в которой одновременно используются как длинные риды с большим количеством ошибок, так и короткие, уровень ошибок в которых минимален. Короткие риды здесь выступают основным материалом для построения графа сборки, а длинные риды позволяют находить более длинные пути в этом графе, которые в дальнейшем становятся контигами. К сожалению, для больших геномов получить достаточное количестве коротких ридов оказывается очень дорого.

Кроме того, даже с небольшими геномами есть проблемы. Например, есть штаммы бактерий, получить большое количество экземпляров которых крайне сложно. В этом случае покрытие генома полученными ридами оказывается очень низким, как и качество длинных ридов. Более того, некоторые штаммы вообще невозможно получить без окружающих их бактерий, поэтому прибегают к метагеномике --- направлению геномики, в котором рассматриваются ДНК не отдельного организма, а сразу множества. Покрытие ридами генома каждой из бактерии в рамках одной сборки может сильно отличаться, что только ухудшает качество контигов бактерий с низким покрытием.

Уже существуют инструменты, которые стараются исправлять контиги используя риды. Их основная идея --- найти выравнивания ридов на контиги и с помощью какого-нибудь алгоритма консенсуса решить, какие нуклеотиды исправлять. При этом подходе теряется информация, которую нам даёт граф сборки. Во-первых, рёбра графа в основном существенно длиннее ридов, а также уже проведена коррекция ошибок в самих ридах. Во-вторых, граф сборки даёт связи между рёбрами. Так как любой контиг это путь в графе, то можно попытаться исправить фрагмент контига, найдя подходящий путь между рёбрами, в местоположении которых в контиге мы уверены.

Итак, оказывается актуальной разработка нового инструмента, позволяющего исправлять ошибки в контигах при помощи графов сборки.

%-----------------------------
%
%сборка геномов важна, всё идёт прогресс
%Расшифровка геномов была важной задачей
%новые технологии позволили получать новые длинные риды дешевле, но количество ошибок в них больше.
%
%Хоть и есть способы с этим бороться, но всё чёт не очень хорошо.
%
%есть гибридные методы, которые и то и то используют, но из-за повторов всё фигня.
%
%Для метагеномики это всё тоже плохо работает.
%Есть низко представленные штаммы бактерий, у них покрытие низкое, а длинные риды тут ещё хуже.


%были разные тулы, которые уже корректят длинные риды по коротким (плохо -- прикладывают короткие к длинным); гибридные сборки тоже. А мы хотим сделать уникальный тул, который по графу и длинным ридам всё восстанавливает.

%\begin{sloppypar}
%\end{sloppypar}


%==============================================================================
\section{Постановка задачи}
Целью данной работы является создание инструмента, позволяющего исправлять ошибки в зашумленных последовательностях при помощи графов сборки. Для достижения этой цели были сформулированы следующие задачи.
\begin{itemize}
    \item Выбор алгоритма прикладывания рёбер графа к последовательностям.
    \item Выбор критериев фильтрации полученных выравниваний.
    \item Разработка алгоритма исправления ошибок за пределами выравненных рёбер.
    \item Разработка алгоритма переноса полученных путей в графе обратно в последовательности.
    \item Реализация итогового алгоритма в виде отдельного инструмента.
    \item Тестирование алгоритма на известных геномах.
\end{itemize}

%==============================================================================
\section{Обзор предметной области}
\subsection{Представление генома}
Большинство природных ДНК состоит из двух скрученных спиралей, к которым крепятся молекулы, называемые нуклеотидами \cite{art:Watson}. Всего в спиралях присутствует четыре вида нуклеотида: аденин (A), цитозин (C), гуанин (G), тимин (T). Двойная спираль ДНК может иметь либо линейную структуру, либо кольцевую. Одноцепочечную ДНК содержат лишь некоторые вирусы и бактериофаги. При этом известно, что одна спираль полностью задаёт другую: напротив каждого нуклеотида из одной цепочки стоит комплементарный ей из другой. Для аденина это тимин, а для гуанина --- цитозин.

Таким образом можно считать, что ДНК состоит из двух комплементарных строк над алфавитом из четырёх букв. Длину подстрок принято измерять в спаренных основаниях (англ. base pair, \textbf{bp}), которые эквивалентны одному символу строки.

\subsection{Сборка геномов}
Современные технологии не могут считывать всю ДНК за раз, поэтому в результате секвенирования получается множество фрагментов ДНК, называемых ридами. В зависимости от используемой технологии, длина ридов может быть разной, но самые популярные технологии умеют получать цепочки нуклеотидов порядка 100-200 bp, в то время как, например, длина генома у бактерий измеряется в миллионах bp. К сожалению, при секвенировании происходят ошибки, поэтому ДНК читается несколько раз, чтобы в перекрытии каждого нуклеотида результирующим набором ридов было больше правильных значений, чем ошибочных.

Задачей ассемблера является восстановление одной из нитей спирали ДНК по ридам. Обычно удаётся  восстановить лишь фрагменты ДНК, которые являются либо контигами, либо скаффолдами. Их отличие в том, что в случае скаффолдов допускаются подстроки, в которых нуклеотиды неизвестны, что даёт дополнительную информацию в виде расстояния между контигами и их порядка следования в геноме.

\subsection{Граф сборки}
Методы сборки ридов в контиги далеко шагнули вперёд. В некоторых современных ассемблерах, таких как SPAdes \cite{art:SPAdes} и Flye \cite{art:flye}, используется подход, основанный на графе де Брюйна (англ. de Bruijn graph) \cite{art:Pevzner}. Этот граф строится по следующим принципам: берётся набор входных строк и выделяется из них множество всевозможных подстрок длины k+1 (k+1-меры). Тогда направленными рёбрами будут выступать k+1-меры. Вершинами же будут k-меры, полученные уже из k+1-меров и выступающие в роли перекрытия между ними. Соответственно, к вершине подсоединяются рёбра тем концом, который содержит k-мер вершины. Пример графа можно видеть на рисунке \ref{fig:debruijn}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{debruijn.png}
	\caption{Граф де Брюйна для строки ACGTCCGTAA с параметром ${k=2}$.}
	\label{fig:debruijn}
\end{figure}

Так как пути в графе де Брюйна образуют контиги, вершины, в которые входит и выходит ровно по одному ребру, можно удалить, объединив соответствующие рёбра в одно. Пример такого упрощения можно видеть на рисунке \ref{fig:debruijn_simpl}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.22]{debruijn_simpl.png}
	\caption{Граф сборки, полученный в результате упрощения графа с рисунка \ref{fig:debruijn}.}
	\label{fig:debruijn_simpl}
\end{figure}

Граф, полученный в результате упрощения графа де Брюйна, называется графом сборки. На самом деле, упрощение необходимо по нескольким причинам, которые описаны в работе \cite{art:disser_andrey}. В частности, это позволяет удалить рёбра, в которых содержатся ошибки.

\subsection{Существующие решения}
\textbf{LoRDEC} \cite{art:salmela2014lordec} был первым, кто использовал граф де Брюйна, построенный из коротких ридов, в качестве индекса для исправления длинных ридов. В LoRDEC длинные риды привязывались к графу, используя общие k-меры. Затем непривязанные подпоследовательности исправлялись с помощью путей, которые похожи на исправляемые подпоследовательности. Многие инструменты для гибридного исправления ошибок в длинных ридах основываются на этом подходе LoRDEC.

\textbf{Jabba} \cite{art:miclotte2016jabba}, помимо использования подхода LoRDEC, перед построением графа применяет самокоррекцию коротких ридов. Кроме этого, длинные риды привязываются к графу, используя максимально точные совпадения, чтобы использовать k-меры разной длины во время исправления ошибок.

\textbf{HG-CoLoR} \cite{art:morisse2018hybrid} также применяет самокоррекцию коротких ридов, а также выравнивает их на длинные риды, чтобы найти перекрытия между собой. Эти перекрытия привязывают риды к графу де Брюйна переменного порядка с учётом разных длин k-меров.

\textbf{FMLRC} \cite{art:wang2018fmlrc} индексирует граф де Брюйна, используя многострочное преобразование Барроуза — Уилера (англ. multi-string Burrows-Wheeler Transform) коротких ридов. Это представление занимает мало места в памяти, допускает несколько длин k-меров и неявно сохраняет частоту появления k-меров. Исправление ошибок в FMLRC происходит в два прохода: во время первого используется небольшое значение k для k-меров, в то время как для второго используется k больше, чтобы упростить граф в особо сложных местах.

\textbf{CoLoRMap} \cite{art:haghshenas2016colormap}, в отличии от вышеупомянутых инструментов, строит граф взвешенных выравниваний из сопоставления коротких ридов длинным. Это сопоставление позволяет получить пути в графе, которые максимально похожи на подпоследовательности исправляемых последовательностей. CoLoRMap использует информацию о парных концах коротких ридов, чтобы перепрыгнуть регионы длинных ридов, которым не сопоставлен ни один короткий рид.

\textbf{Ratatosk} \cite{art:holley2021ratatosk} в свою очередь, во первых, раскрашивает вершины графа де Брюйна с помощью коротких и длинных ридов, чтобы выделить существующие пути для исправления. Раскраска графа позволяет уменьшить пространство обхода графа, удаляя химерные пути.
Во вторых, длинные риды привязываются к графу, используя как точное совпадение k-меров, так и неточное, что позволяет привязать регионы с большим количеством ошибок. В третьих, граф аннотируется кандидатами на точечные ошибки в один нуклеотид, что позволяет выделить небольшие вариации между гаплотипами, которые трудно уловить из ошибочных длинных ридов. В четвёртых, коррекция выполняется в два прохода, используя короткие и длинные риды по отдельности.

Для получения большей информации об исправлении ошибок в длинных ридах можно воспользоваться обзорами \cite{art:morisse2020long, art:zook2016extensive, art:zhang2020comprehensive}.

% \subsection{Выравниватели последовательностей}

%==============================================================================
\section{Алгоритм}
Алгоритм коррекции состоит из следующей последовательности шагов.
\begin{enumerate}
    \item Исправляемые последовательности выравниваются на граф с помощью minimap. Так как в графе уже присутствуют как прямые рёбра, так и обратно-комплементарные, используется флаг \texttt{----for-only} для получения выравниваний на рёбра только в их прямом направлении. Кроме того, так как в графе есть неуникальные рёбра (например, отражают повтор в геноме или принадлежат нескольким организмам в метагеноме), используется флаг \texttt{----secondary=yes}, чтобы получить все выравнивания, которые нашёл minimap.
    \item Найденных выравниваний довольно много, они перекрывают друг друга, и далеко не все из них действительно должны находиться на найденных местах (например, повторы). Поэтому их нужно отфильтровать. Те выравнивания рёбер, что останутся, будем называть \textit{якорями}.
    \item Помимо исправления последовательностей непосредственно якорями, нужно исправлять и другие места. Для этого между якорями находятся пути, которые затем смешиваются для получения \textit{строки-заменителя}. Якоря со строками-заменителями между ними образуют \textit{смешанный путь} в графе.
    \item Полученные смешанные пути переносятся в исправляемые последовательности.
\end{enumerate}

\subsection{Выбор якорей}
Из множества всех найденных выравниваний на рёбра графа нас интересуют те, которые ``скорее всего'' находятся на правильном месте. Так, например, с увеличением длины ребра, вероятность, что оно будет выравнено на множество мест, уменьшается. По нашим наблюдениям, выравнивания рёбер, которые длиннее 2000 символов, можно считать уникальными даже в метагеномной сборке.

Для повышения вероятности правильности выравнивания производится фильтрация по следующим критериям:
\begin{itemize}
    \item длина выравнивания (а значит и длина ребра) $> 500$ символов;
    \item идентичность\footnote{Отношение удвоенного количества совпавших символов к сумме длин сопоставленных подстрок} (англ. identity) выравнивания $> 90\%$;
    \item покрытие\footnote{Среднее количество уникальных ридов, которые были использованы для создания нуклеотидов ребра} (англ. coverage) ребра $> 2$;
    \item разница длин выравненных фрагмента последовательности и фрагмента ребра не превышает $5\%$;
    \item выравнивание является одним из случаев:
    \begin{itemize}
        \item ребро полностью содержится в последовательности;
        \item последовательность полностью содержится в ребре;
        \item конец ребра ($>1000$) является началом последовательности;
        \item начало ребра ($>1000$) является концом последовательности\footnote{Часто ``конец/начало ребра/последовательности'' не является суффиксом/префиксом из-за наличия ошибок, поэтому необходимо допускать небольшой отступ, например, не больше 50 символов.};
    \end{itemize}
\end{itemize}
Оставшиеся после фильтрации рёбра в выравниваниях будем называть \textit{якорями}. 

Для каждого якоря определяется уровень достоверности:
\begin{enumerate}
    \item $\ge$ 2000 символов -- почти наверное уникальные;
    \item $\ge$ 1000 символов -- вероятно уникальные;
    \item $\ge$ 500 символов -- возможно уникальные;
\end{enumerate}

После фильтрации якоря потенциально всё ещё могут быть взаимоисключающими (то есть пересекаться больше, чем на k\footnote{Количество символов пересечения смежных рёбер в графе}$+\varepsilon$\footnote{Несколько символов для возможных ошибок, например, $5$}). Взаимоисключающие рёбра отбрасываются следующим образом:
\begin{itemize}
    \item для каждой пары якорей проверяется, конфликтуют ли они. Если да, то:
    \begin{itemize}
        \item если их длины отличаются больше, чем в два раза, то на удаление помечается тот, что с меньшей;
        \item иначе помечаются оба;
    \end{itemize}
    \item все помеченные якоря разом отбрасываются;
\end{itemize}

Тем не менее, критериев фильтрации на практике оказывается достаточно, чтобы взаимоисключающих рёбер не было вообще.

\subsection{Пути между якорями}
Расположим якоря в порядке встречи их в последовательности. Заполнение пространства вне якорей проходит следующим образом.
\begin{itemize}
    \item Для каждой пары смежных якорей самого достоверного класса находятся пути в графе, которые отличаются не больше, чем на $10\%$ от длины фрагмента последовательности между этими якорями. Найденные пути затем и смешиваются и формируют строки-заменители.
    \item Если между двумя якорями (а также до первого и после последнего) не было сформировано строк-заменителей, то в этот промежуток добавляются якоря из следующего класса достоверности и процесс поиска-смешивания-формирования повторяется.
\end{itemize}

Между якорями ищутся все пути, чтобы на этапе смешивания быть уверенным, что различия между гаплотипами не будут потеряны. Так как графы устроены довольно сложно, путей даже между не очень удалёнными якорями (несколько тысяч символов) может быть чрезвычайно много (десятки и сотни тысяч), то поиск имеет несколько ограничений, выход за которые, как показывает наша практика, не имеет смысла. Сам поиск проходит в два этапа.
\begin{enumerate}
    \item С помощью алгоритма Дейкстры в графе помечаются все вершины, через которые существует путь с заданным ограничением сверху на длину. Количество найденных вершин не должно превышать 3000.
    \item Поиском в глубину по помеченным вершинам выбираются все пути с заданными ограничениями на длину. При этом суммарное количество рекурсивных вызовов не должно превышать 3000, а если оно превысило 500, то дополнительно проверяется, чтобы в найденном пути было не больше 5 одинаковых рёбер.
\end{enumerate}
Если поиск обнаружил превышение данных ограничений, процесс получения строки-заполнителя между текущей парой якорей прерывается. Эти ограничения выбраны таким образом, чтобы большинство случаев поиска завершалось с большим запасом до их превышения, но на слишком запутанных частях графа они быстро прерывались.

\subsection{Смешивание путей}
После того, как все пути между якорями найдены, необходимо понять, что из этого может исправить последовательность, а что испортить. 
Для этого каждый путь выравнивается на фрагмент последовательности. Если расстояние между ними слишком велико, то этот путь отбрасывается. Часть с выравниванием является самой трудоёмкой частью всего пайплайна коррекции и занимает больше $95\%$ времени, поэтому происходит параллельно.

Оставшиеся пути упорядочиваются в порядке возрастания расстояния. Если остался всего один путь, или у первого пути расстояние меньше, чем у второго в два раза и на десять\footnote{Довольно часто лучшие пути имеют расстояние 0-5, что является несущественным отличием, чтобы однозначно сказать, что какой-то путь лучше.}, то этот путь становится \textit{кандидатом} на строку-заменитель.

Не каждый кандидат становится строкой-заменителем. Чтобы это произошло, он должен отличаться от фрагмента последовательности не больше, чем на $2\%$.

Довольно часто все найденные пути являются порождением подграфа, который представляет из себя набор ``пузырей'', например, как на рисунке \ref{fig:buldges}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{buldges.png}
    \caption{Подграф, содержащий два ``пузыря''.}
    \label{fig:buldges}
\end{figure}

Пузыри зачастую образуются в результате наличия повторов в геноме, или когда есть похожие фрагменты у двух организмов (например, двух штаммах бактерии) в метагеноме. Рёбра в них отличаются весьма слабо, поэтому, если разложить такой подграф на два пути (с рисунка \ref{fig:buldges} это $axbyc$ и $ax'buvc$), можно выравнять эти пути межу собой, найти места, которые в них отличаются, и заменить их на фрагменты из исправляемой последовательности. Таким образом вариации между гаплотипами будут сохранены, а ошибки исправлены. Полученная строка является также лишь кандидатом на строку-заменитель, чтобы избежать случайного внесения большого количества ошибок в последовательность.

\subsection{Перенос путей в последовательность}
После того, как будут получены строки-заменители, их необходимо разместить обратно в исправляемую последовательность. Для определения фрагмента последовательности, соответствующего данной строке, используются выравнивания minimap с первого шага --- это диапазон с позиции первого символа первого якоря в составе строки до позиции последнего символа в последнем якоре в составе строки. Стоит отметить, что диапазоны строк-заменителей могут пересекаться вплоть до $k+\varepsilon$, при этом символы в перекрытии могут не совпадать. Чтобы избежать внесения ошибок можно воспользоваться двумя стратегиями:
\begin{itemize}
    \item отрезать перекрытие у каждой из строк-заменителей, не меняя исходную последовательность;
    \item воспользоваться смешиванием из предыдущего шага, тем самым исправляя общие символы и не меняя несовпадающие.
\end{itemize}

%==============================================================================
\section{Альтернативный алгоритм}
Можно заметить, что решение довольно похоже на решение задачи выравнивания последовательностей на граф (т.е. нахождение как можно более длинных путей в графе, которые соответствуют фрагментам последовательностей). Кажется, что отличие лишь в том, что мы дополнительно по-умному смешиваем пути между якорями на уровне нуклеотидов. Рассмотрим альтернативный алгоритм:
\begin{enumerate}
    \item взять существующий выравниватель на граф;
    \item взять несколько лучших выравниваний для каждого фрагмента последовательности;
    \item смешать найденные пути;
\end{enumerate}

\subsection{Кластеризация}
\begin{sloppypar}
Для проверки данного алгоритма был взят выравниватель GraphAligner. Он уже выдаёт несколько лучших найденных выравниваний для каждой области последовательности. Так как пути покрывают похожие, но не идентичные фрагменты, нужно разбить пути на кластера, которые будут покрывать как можно больше длины последовательности, и как можно меньше пересекаться (т.е. конфликтовать) друг с другом. Для этого будем последовательно объединять пути в кластера по следующему критерию: если два пути перекрываются выравниваниями больше, чем на $70\%$, то они лежат в одном кластере. Как показывает практика, на наших тестах этого критерия было достаточно, чтобы лучшие по идентичности пути в кластерах покрывали последовательность на $95-100\%$, все пути в кластере попарно пересекались минимум на $70\%$, а пути различных кластеров практически не пересекались ($<1\%$).
\end{sloppypar}

\subsection{Смешивание}
Пути в полученных кластерах смешиваются следующим образом.
\begin{enumerate}
    \item Выбирается лучший путь в кластере по идентичности с последовательностью.
    \item Все остальные пути выравниваются на лучший.
    \item По полученным выравниваниям помечаем символы и позиции между символами лучшего пути помечаются недостоверными, если хотя бы в одном выравнивании есть отличие.
    \item Заменяем недостоверные места символами из последовательности.
\end{enumerate}

Полученные после смешения строки переносятся обратно способом, описанным главе ``Перенос путей в последовательность''.

%==============================================================================
\section{Тестирование}
В данном разделе приводится сравнение двух алгоритмов, представленных в работе. Тестирование проводилось на метагеноме Zymo, граф из коротких ридов получен ассемблером SPAdes, а последовательности для исправления являются контигами, полученными в результате сборки из длинных ридов ассемблером Flye. Инструментом для сравнения является Quast. Сравнение ведётся по двум метрикам точечных ошибок: 
\begin{itemize}
    \item количество замен символов на неправильные;
    \item количество вставленных ошибочных и удалённых правильных символов;
\end{itemize}

Столбцы на рисунках \ref{fig:indels_ga} и \ref{fig:mismatches_ga}:
\begin{enumerate}
    \item бактерии, входящие в состав метагенома;
    \item контиги Flye без коррекции;
    \item контиги после коррекции основным алгоритмом;
    \item контиги после коррекции альтернативным алгоритмом;
    \item контиги после коррекции альтернативным алгоритмом с той лишь разницей, что после выбора лучшего пути смешения с остальными не происходит;
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{indels_ga_full.png}
    \caption{Вставки и удаления}
    \label{fig:indels_ga}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{mismatches_ga_full.png}
    \caption{Замены}
    \label{fig:mismatches_ga}
\end{figure}

По вставкам и удалениям альтернативный алгоритм местами существенно обходит основной.

По количеству замен альтернативный алгоритм не только проигрывает основному алгоритму, но и в половине случаев вносит ошибок больше, чем исправляет. Особое внимание стоит обратить на бактерию Salmonella Enterica, для неё пути GraphAligner прошлись по похожим рёбрам другой бактерии, что привело к всплеску замен.

%==============================================================================
%% У заключения нет номера главы
%\newpage
%\[\]
\newpage
\section*{Заключение}
В ходе данной работы были получены следующие результаты.
\begin{itemize}
    \item Выбран алгоритм прикладывания рёбер графа к последовательностям.
    \item Сформированы критерии фильтрации полученных выравниваний.
    \item Разработан алгоритм исправления ошибок за пределами выравненных рёбер.
    \item Разработан алгоритм переноса полученных путей в графе обратно в последовательности.
    \item Итоговый алгоритм реализован в виде отдельного инструмента.
    \begin{itemize}
        \item Реализация выполнена на языке C++ и является подпроектом для ассемблера SPAdes.
        \item \begin{sloppypar} Исходный код SPAdes доступен по ссылке: \mbox{\url{https://github.com/ablab/spades/}}. Реализованный инструмент будет доступен начиная с версии 3.17. \end{sloppypar}
    \end{itemize}
\end{itemize}

В весеннем семестре будет проведена апробация алгоритмов, улучшены и добавлены новые метрики и алгоритмы фильтрации выравниваний и исправления ошибок за пределами якорей.

%==============================================================================

\section*{Глоссарий}

\textbf{Ассемблер} --- программное обеспечение для получение контигов и скаффолдов из ридов.\\

\textbf{Граф де Брюйна} --- граф с параметром k, в котором рёбрами являются все возможные подстрок длины k+1 из некоторого набора строк, а вершинами --- перекрытия этих подстрок в k позициях.\\

\textbf{Граф сборки} --- в этой работе: граф, полученный в результате упрощения графа де Брюйна.\\

%\textbf{К-мер} --- последовательность длины К.\\

%\textbf{Покрывающий путь} --- путь, проходящий через заданное ребро.\\

%\textbf{Плазмиды} --- небольшие молекулы ДНК, физически отделённые от хромосом.\\

%\textbf{Референсный геном} --- эталонный геном данного вида организма.\\

\textbf{Риды} --- множество фрагментов ДНК, которые получаются в результате секвенирования.\\

\textbf{Контиги} --- восстановленные части ДНК из ридов.\\

\textbf{Скаффолд} --- объединение нескольких контигов с известным расстоянием между ними, но неизвестными самими нуклеотидами.\\

%==============================================================================

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma}
\end{document}
